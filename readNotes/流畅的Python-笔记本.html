
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "XHTML1-s.dtd" >
<html xmlns="http://www.w3.org/TR/1999/REC-html-in-xml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
<style>
.bodyContainer {
    font-family: Arial, Helvetica, sans-serif;
    text-align: center;
    padding-left: 32px;
    padding-right: 32px;
}

.notebookFor {
    font-size: 18px;
    font-weight: 700;
    text-align: center;
    color: rgb(119, 119, 119);
    margin: 24px 0px 0px;
    padding: 0px;
}

.bookTitle {
    font-size: 32px;
    font-weight: 700;
    text-align: center;
    color: #333333;
    margin-top: 22px;
    padding: 0px;
}

.authors {
    font-size: 13px;
    font-weight: 700;
    text-align: center;
    color: rgb(119, 119, 119);
    margin-top: 22px;
    margin-bottom: 24px; 
    padding: 0px;
}

.sectionHeading {
    font-size: 24px;
    font-weight: 700;
    text-align: left;
    color: #333333;
    margin-top: 24px;
    padding: 0px;
}

.noteHeading {
    font-size: 18px;
    font-weight: 700;
    text-align: left;
    color: #333333;
    margin-top: 20px;
    padding: 0px;
}

.noteText {
    font-size: 18px;
    font-weight: 500;
    text-align: left;
    color: #333333;
    margin: 2px 0px 0px;
    padding: 0px;
}

.highlight_blue {
    color: rgb(178, 205, 251);
}

.highlight_orange {
    color: #ffd7ae;
}

.highlight_pink {
    color: rgb(255, 191, 206);
}

.highlight_yellow {
    color: rgb(247, 206, 0);
}

.notebookGraphic {
    margin-top: 10px;
    text-align: left;
}

.notebookGraphic img {
    -o-box-shadow:      0px 0px 5px #888;
    -icab-box-shadow:   0px 0px 5px #888;
    -khtml-box-shadow:  0px 0px 5px #888;
    -moz-box-shadow:    0px 0px 5px #888;
    -webkit-box-shadow: 0px 0px 5px #888;
    box-shadow:         0px 0px 5px #888; 
    max-width: 100%;
    height: auto;
}

hr {
    border: 0px none;
    height: 1px;
    background: none repeat scroll 0% 0% rgb(221, 221, 221);
}
</style>
</head>
<body>
<div class='bodyContainer'>
<div class='notebookFor'>笔记本（用于）</div><div class='bookTitle'>流畅的Python
</div><div class='authors'>
[巴西] Luciano Ramalho
</div><hr/>
<div class='sectionHeading'>1.2　如何使用特殊方法</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 593</div><div class='noteText'>通 常 你 的 代 码 无 需 直 接 使 用 特 殊 方 法。 除 非 有 大 量 的 元 编 程 存 在， 直 接 调 用 特 殊 方 法 的 频 率 应 该 远 远 低 于 你 去 实 现 它 们 的 次 数。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 601</div><div class='noteText'>不 要 自 己 想 当 然 地 随 意 添 加 特 殊 方 法， 比 如 __foo__ 之 类 的， 因 为 虽 然 现 在 这 个 名 字 没 有 被 Python 内 部 使 用， 以 后 就 不 一 定 了。</div>
<div class='sectionHeading'>1.2.4　自定义的布尔值</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 717</div><div class='noteText'>在 Python 标 准 库 的 文 档 中， 有 一 节 叫 作“ Built-in Types”， 其 中 规 定 了 真 值 检 验 的 标 准。 通 过 实 现 __bool__， 你 定 义 的 对 象 就 可 以 与 这 个 标 准 保 持 一 致。</div>
<div class='sectionHeading'>1.4　为什么len不是普通方法</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 844</div><div class='noteText'>换 句 话 说， len 之 所 以 不 是 一 个 普 通 方 法， 是 为 了 让 Python 自 带 的 数 据 结 构 可 以 走 后 门， abs 也 是 同 理。 但 是 多 亏 了 它 是 特 殊 方 法， 我 们 也 可 以 把 len 用 于 自 定 义 数 据 类 型。 这 种 处 理 方 式 在 保 持 内 置 类 型 的 效 率 和 保 证 语 言 的 一 致 性 之 间 找 到 了 一 个 平 衡 点， 也 印 证 了“ Python 之 禅” 中 的 另 外 一 句 话：“ 不 能 让 特 例 特 殊 到 开 始 破 坏 既 定 规 则。”</div>
<div class='sectionHeading'>第 2 章　序列构成的数组</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 924</div><div class='noteText'>深 入 理 解 Python 中 的 不 同 序 列 类 型， 不 但 能 让 我 们 避 免 重 新 发 明 轮 子， 它 们 的 API 还 能 帮 助 我 们 把 自 己 定 义 的 API 设 计 得 跟 原 生 的 序 列 一 样， 或 者 是 跟 未 来 可 能 出 现 的 序 列 类 型 保 持 兼 容。</div>
<div class='sectionHeading'>2.1　内置序列类型概览</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 940</div><div class='noteText'>容 器 序 列 存 放 的 是 它 们 所 包 含 的 任 意 类 型 的 对 象 的 引 用， 而 扁 平 序 列 里 存 放 的 是 值 而 不 是 引 用。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 941</div><div class='noteText'>扁 平 序 列 其 实 是 一 段 连 续 的 内 存 空 间。 由 此 可 见 扁 平 序 列 其 实 更 加 紧 凑， 但 是 它 里 面 只 能 存 放 诸 如 字 符、 字 节 和 数 值 这 种 基 础 类 型。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 959</div><div class='noteText'>通 过 记 住 这 些 类 的 共 有 特 性， 把 可 变 与 不 可 变 序 列 或 是 容 器 与 扁 平 序 列 的 概 念 融 会 贯 通， 在 探 索 并 学 习 新 的 序 列 类 型 时， 你 会 更 加 得 心 应 手。</div>
<div class='sectionHeading'>2.2.1　列表推导和可读性</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 986</div><div class='noteText'>通 常 的 原 则 是， 只 用 列 表 推 导 来 创 建 新 的 列 表， 并 且 尽 量 保 持 简 短。 如 果 列 表 推 导 的 代 码 超 过 了 两 行， 你 可 能 就 要 考 虑 是 不 是 得 用 for 循 环 重 写 了。 就 跟 写 文 章 一 样， 并 没 有 什 么 硬 性 的 规 则， 这 个 度 得 你 自 己 把 握。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1004</div><div class='noteText'>Python 3 中 都 有 了 自 己 的 局 部 作 用 域， 就 像 函 数 似 的。 表 达 式 内 部 的 变 量 和 赋 值 只 在 局 部 起 作 用， 表 达 式 的 上 下 文 里 的 同 名 变 量 还 可 以 被 正 常 引 用， 局 部 变 量 并 不 会 影 响 到 它 们。</div>
<div class='sectionHeading'>2.2.2　列表推导同filter和map的比较</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1024</div><div class='noteText'>我 原 以 为 map/ filter 组 合 起 来 用 要 比 列 表 推 导 快 一 些， Alex Martelli 却 说 不 一 定—— 至 少 在 上 面 这 个 例 子 中 不 一 定。</div>
<div class='sectionHeading'>2.2.3　笛卡儿积</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1054</div><div class='noteText'>列 表 推 导 的 作 用 只 有 一 个： 生 成 列 表。 如 果 想 生 成 其 他 类 型 的 序 列， 生 成 器 表 达 式 就 派 上 了 用 场。</div>
<div class='sectionHeading'>2.2.4　生成器表达式</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1057</div><div class='noteText'>生 成 器 表 达 式 是 更 好 的 选 择。 这 是 因 为 生 成 器 表 达 式 背 后 遵 守 了 迭 代 器 协 议， 可 以 逐 个 地 产 出 元 素， 而 不 是 先 建 立 一 个 完 整 的 列 表， 然 后 再 把 这 个 列 表 传 递 到 某 个 构 造 函 数 里。 前 面 那 种 方 式 显 然 能 够 节 省 内 存。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1079</div><div class='noteText'>第 14 章 会 专 门 讲 到 生 成 器 的 工 作 原 理。 这 里 只 是 简 单 看 看 如 何 用 生 成 器 来 初 始 化 除 列 表 之 外 的 序 列， 以 及 如 何 用 它 来 避 免 额 外 的 内 存 占 用。</div>
<div class='sectionHeading'>2.3　元组不仅仅是不可变的列表</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1083</div><div class='noteText'>有 些 Python 入 门 教 程 把 元 组 称 为“ 不 可 变 列 表”， 然 而 这 并 没 有 完 全 概 括 元 组 的 特 点。 除 了 用 作 不 可 变 的 列 表， 它 还 可 以 用 于 没 有 字 段 名 的 记 录。</div>
<div class='sectionHeading'>2.3.2　元组拆包</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1116</div><div class='noteText'>被 可 迭 代 对 象 中 的 元 素 数 量 必 须 要 跟 接 受 这 些 元 素 的 元 组 的 空 档 数 一 致。 除 非 我 们 用 * 来 表 示 忽 略 多 余 的 元 素，</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1119</div><div class='noteText'>可 迭 代 元 素 拆 包</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1128</div><div class='noteText'>还 可 以 用 * 运 算 符 把 一 个 可 迭 代 对 象 拆 开 作 为 函 数 的 参 数：</div>
<div class='sectionHeading'>2.3.3　嵌套元组拆包</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1158</div><div class='noteText'>接 受 表 达 式 的 元 组 可 以 是 嵌 套 式 的， 例 如 (a, b, (c, d))。 只 要 这 个 接 受 元 组 的 嵌 套 结 构 符 合 表 达 式 本 身 的 嵌 套 结 构， Python 就 可 以 作 出 正 确 的 对 应。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1177</div><div class='noteText'>元 组 可 以 作 为 形 参 放 在 函 数 声 明 中， 例 如 def fn( a, (b, c), d):。 然 而 Python 3 不 再 支 持 这 种 格 式，</div>
<div class='sectionHeading'>2.3.4　具名元组</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1184</div><div class='noteText'>数， 它 可 以 用 来 构 建 一 个 带 字 段 名 的 元 组 和 一 个 有 名 字 的 类—— 这 个 带 名 字 的 类 对 调 试 程 序 有 很 大 帮 助。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1215</div><div class='noteText'>通 过 接 受 一 个 可 迭 代 对 象 来 生 成 这 个 类 的 一 个 实 例， 它 的 作 用 跟 City(* delhi_data) 是 一 样 的。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1218</div><div class='noteText'>把 具 名 元 组 以 collections.OrderedDict 的 形 式 返 回，</div>
<div class='sectionHeading'>2.4　切片</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1353</div><div class='noteText'>这 么 做 主 要 是 为 了 符 合 这 本 书 的 哲 学： 先 讲 用 法，</div>
<div class='sectionHeading'>2.4.2　对对象进行切片</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1401</div><div class='noteText'>切 片 还 有 个 两 个 额 外 的 功 能： 多 维 切 片 和 省 略 表 示 法（...）。</div>
<div class='sectionHeading'>2.4.3　多维切片和省略</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1418</div><div class='noteText'>它 可 以 当 作 切 片 规 范 的 一 部 分， 也 可 以 用 在 函 数 的 参 数 清 单 中，</div>
<div class='sectionHeading'>2.4.4　给切片赋值</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1433</div><div class='noteText'>如 果 把 切 片 放 在 赋 值 语 句 的 左 边， 或 把 它 作 为 del 操 作 的 对 象， 我 们 就 可 以 对 序 列 进 行 嫁 接、 切 除 或 就 地 修 改 操 作。</div>
<div class='sectionHeading'>2.5　对序列使用+和*</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1460</div><div class='noteText'>但 是 你 得 到 的 列 表 里 包 含 的 3 个 元 素 其 实 是 3 个 引 用， 而 且 这 3 个 引 用 指 向 的 都 是 同 一 个 列 表。 这 可 能 不 是 你 想 要 的 效 果。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1462</div><div class='noteText'>* 来 初 始 化 一 个 由 列 表 组 成 的 列 表。</div>
<div class='sectionHeading'>建立由列表组成的列表</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1481</div><div class='noteText'>一 旦 我 们 试 图 标 记 第 1 行 第 2 列 的 元 素， 就 立 马 暴 露 了 列 表 内 的 3 个 引 用 指 向 同 一 个 对 象 的 事 实。</div>
<div class='sectionHeading'>2.6　序列的增量赋值</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1510</div><div class='noteText'>如 果 a 实 现 了 __iadd__ 方 法， 就 会 调 用 这 个 方 法。 同 时 对 可 变 序 列（ 例 如 list、 bytearray 和 array.array） 来 说， a 会 就 地 改 动， 就 像 调 用 了 a.extend( b) 一 样。 但 是 如 果 a 没 有 实 现 __iadd__ 的 话， a + = b 这 个 表 达 式 的 效 果 就 变 得 跟 a = a + b 一 样 了： 首 先 计 算 a + b， 得 到 一 个 新 的 对 象， 然 后 赋 值 给 a。 也 就 是 说， 在 这 个 表 达 式 中， 变 量 名 会 不 会 被 关 联 到 新 的 对 象， 完 全 取 决 于 这 个 类 型 有 没 有 实 现 __iadd__ 这 个 方 法。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1536</div><div class='noteText'>对 不 可 变 序 列 进 行 重 复 拼 接 操 作 的 话， 效 率 会 很 低， 因 为 每 次 都 有 一 个 新 对 象， 而 解 释 器 需 要 把 原 来 对 象 中 的 元 素 先 复 制 到 新 的 对 象 里， 然 后 再 追 加 新 的 元 素。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1539</div><div class='noteText'>4str 是 一 个 例 外， 因 为 对 字 符 串 做 + = 实 在 是 太 普 遍 了， 所 以 CPython 对 它 做 了 优 化。 为 str 初 始 化 内 存 的 时 候， 程 序 会 为 它 留 出 额 外 的 可 扩 展 空 间， 因 此 进 行 增 量 操 作 的 时 候， 并 不 会 涉 及 复 制 原 有 字 符 串 到 新 位 置 这 类 操 作。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1544</div><div class='noteText'>这 个 例 子 可 以 说 是 突 出 展 示 了“ 不 可 变 性” 对 于 元 组 来 说 到 底 意 味 着 什 么。</div>
<div class='sectionHeading'>一个关于+=的谜题</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1593</div><div class='noteText'>不 要 把 可 变 对 象 放 在 元 组 里 面。 增 量 赋 值 不 是 一 个 原 子 操 作。 我 们 刚 才 也 看 到 了， 它 虽 然 抛 出 了 异 常， 但 还 是 完 成 了 操 作。</div>
<div class='sectionHeading'>2.7　list.sort方法和内置函数sorted</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1601</div><div class='noteText'>list.sort 方 法 会 就 地 排 序 列 表， 也 就 是 说 不 会 把 原 列 表 复 制 一 份。 这 也 是 这 个 方 法 的 返 回 值 是 None 的 原 因， 提 醒 你 本 方 法 不 会 新 建 一 个 列 表。 在 这 种 情 况 下 返 回 None 其 实 是 Python 的 一 个 惯 例： 如 果 一 个 函 数 或 者 方 法 对 对 象 进 行 的 是 就 地 改 动， 那 它 就 应 该 返 回 None， 好 让 调 用 者 知 道 传 入 的 参 数 发 生 了 变 动， 而 且 并 未 产 生 新 的 对 象。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1651</div><div class='noteText'>已 排 序 的 序 列 可 以 用 来 进 行 快 速 搜 索， 而 标 准 库 的 bisect 模 块 给 我 们 提 供 了 二 分 查 找 算 法。</div>
<div class='sectionHeading'>2.8.1　用bisect来搜索</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1703</div><div class='noteText'>bisect_left 返 回 的 插 入 位 置 是 原 序 列 中 跟 被 插 入 元 素 相 等 的 元 素 的 位 置， 也 就 是 新 元 素 会 被 放 置 于 它 相 等 的 元 素 的 前 面， 而 bisect_right 返 回 的 则 是 跟 它 相 等 的 元 素 之 后 的 位 置。</div>
<div class='sectionHeading'>2.8.2　用bisect.insort插入新元素</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1733</div><div class='noteText'>insort( seq, item) 把 变 量 item 插 入 到 序 列 seq 中， 并 能 保 持 seq 的 升 序 顺 序。</div>
<div class='sectionHeading'>2.9　当列表不是首选时</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1752</div><div class='noteText'>要 存 放 1000 万 个 浮 点 数 的 话， 数 组（ array） 的 效 率 要 高 得 多， 因 为 数 组 在 背 后 存 的 并 不 是 float 对 象， 而 是 数 字 的 机 器 翻 译， 也 就 是 字 节 表 述。 这 一 点 就 跟 C 语 言 中 的 数 组 一 样。 再 比 如 说， 如 果 需 要 频 繁 对 序 列 做 先 进 先 出 的 操 作， deque（ 双 端 队 列） 的 速 度 应 该 会 更 快。</div>
<div class='sectionHeading'>2.9.1　数组</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1798</div><div class='noteText'>另 外 一 个 快 速 序 列 化 数 字 类 型 的 方 法 是 使 用 pickle 模 块。 pickle.dump 处 理 浮 点 数 组 的 速 度 几 乎 跟 array.tofile 一 样 快。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 1803</div><div class='noteText'>还 有 一 些 特 殊 的 数 字 数 组， 用 来 表 示 二 进 制 数 据， 比 如 光 栅 图 像。 里 面 涉 及 的 bytes 和 bytearry 类 型 会 在 第 4 章 提 及。</div>
<div class='sectionHeading'>2.9.2　内存视图</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 2009</div><div class='noteText'>如 果 利 用 数 组 来 做 高 级 的 数 字 处 理 是 你 的 日 常 工 作， 那 么 NumPy 和 SciPy 应 该 是 你 的 常 用 武 器。 下 面 就 是 对 这 两 个 库 的 简 单 介 绍。</div>
<div class='sectionHeading'>2.9.3　NumPy和SciPy</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 2013</div><div class='noteText'>NumPy 实 现 了 多 维 同 质 数 组（ homogeneous array） 和 矩 阵，</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 2015</div><div class='noteText'>SciPy 是 基 于 NumPy 的 另 一 个 库， 它 提 供 了 很 多 跟 科 学 计 算 有 关 的 算 法， 专 为 线 性 代 数、 数 值 积 分 和 统 计 学 而 设 计。 SciPy 的 高 效 和 可 靠 性 归 功 于 其 背 后 的 C 和 Fortran 代 码， 而 这 些 跟 计 算 有 关 的 部 分 都 源 自 于 Netlib 库。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 2062</div><div class='noteText'>在 介 绍 完 扁 平 序 列（ 包 括 标 准 数 组 和 NumPy 数 组） 之 后， 让 我 们 把 目 光 投 向 Python 中 可 以 取 代 列 表 的 另 外 一 种 数 据 结 构： 队 列。</div>
<div class='sectionHeading'>2.9.4　双向队列和其他形式的队列</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 2070</div><div class='noteText'>collections.deque 类（ 双 向 队 列） 是 一 个 线 程 安 全、 可 以 快 速 从 两 端 添 加 或 者 删 除 元 素 的 数 据 类 型。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 2071</div><div class='noteText'>如 果 想 要 有 一 种 数 据 类 型 来 存 放“ 最 近 用 到 的 几 个 元 素”， deque 也 是 一 个 很 好 的 选 择。 这 是 因 为 在 新 建 一 个 双 向 队 列 的 时 候， 你 可 以 指 定 这 个 队 列 的 大 小， 如 果 这 个 队 列 满 员 了， 还 可 以 从 反 向 端 删 除 过 期 的 元 素， 然 后 在 尾 端 添 加 新 的 元 素。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 2098</div><div class='noteText'>双 向 队 列 也 付 出 了 一 些 代 价， 从 队 列 中 间 删 除 元 素 的 操 作 会 慢 一 些， 因 为 它 只 对 在 头 尾 的 操 作 进 行 了 优 化。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 2100</div><div class='noteText'>append 和 popleft 都 是 原 子 操 作， 也 就 说 是 deque 可 以 在 多 线 程 程 序 中 安 全 地 当 作 先 进 先 出 的 栈 使 用， 而 使 用 者 不 需 要 担 心 资 源 锁 的 问 题。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 2238</div><div class='noteText'>提 供 了 同 步（ 线 程 安 全） 类 Queue、 LifoQueue 和 PriorityQueue， 不 同 的 线 程 可 以 利 用 这 些 数 据 类 型 来 交 换 信 息。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 2241</div><div class='noteText'>这 三 个 类 的 构 造 方 法 都 有 一 个 可 选 参 数 maxsize， 它 接 收 正 整 数 作 为 输 入 值， 用 来 限 定 队 列 的 大 小。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 2243</div><div class='noteText'>反， 如 果 队 列 满 了， 它 就 会 被 锁 住， 直 到 另 外 的 线 程 移 除 了 某 个 元 素 而 腾 出 了 位 置。 这 一 特 性 让 这 些 类 很 适 合 用 来 控 制 活 跃 线 程 的 数 量。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 2246</div><div class='noteText'>这 个 包 实 现 了 自 己 的 Queue， 它 跟 queue.Queue 类 似， 是 设 计 给 进 程 间 通 信 用 的。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 2247</div><div class='noteText'>同 时 还 有 一 个 专 门 的 multiprocessing.JoinableQueue 类 型， 可 以 让 任 务 管 理 变 得 更 方 便。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 2250</div><div class='noteText'>Python 3.4 新 提 供 的 包， 里 面 有 Queue、 LifoQueue、 PriorityQueue 和 JoinableQueue， 这 些 类 受 到 queue 和 multiprocessing 模 块 的 影 响， 但 是 为 异 步 编 程 里 的 任 务 管 理 提 供 了 专 门 的 便 利。</div>
<div class='sectionHeading'>2.10　本章小结</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 2263</div><div class='noteText'>要 想 写 出 准 确、 高 效 和 地 道 的 Python 代 码， 对 标 准 库 里 的 序 列 类 型 的 掌 握 是 不 可 或 缺 的。</div>
<div class='sectionHeading'>3.1　泛映射类型</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 2453</div><div class='noteText'>如 果 一 个 对 象 是 可 散 列 的， 那 么 在 这 个 对 象 的 生 命 周 期 中， 它 的 散 列 值 是 不 变 的， 而 且 这 个 对 象 需 要 实 现 __hash__() 方 法。 另 外 可 散 列 对 象 还 要 有 __qe__() 方 法， 这 样 才 能 跟 其 他 键 做 比 较。 如 果 两 个 可 散 列 对 象 是 相 等 的， 那 么 它 们 的 散 列 值 一 定 是 一 样 的……</div>
<div class='sectionHeading'>用setdefault处理找不到的键</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 2711</div><div class='noteText'>获 取 单 词 的 出 现 情 况 列 表， 如 果 单 词 不 存 在， 把 单 词 和 一 个 空 列 表 放 进 映 射， 然 后 返 回 这 个 空 列 表， 这 样 就 能 在 不 进 行 第 二 次 查 找 的 情 况 下 更 新 列 表 了。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 2718</div><div class='noteText'>二 者 的 效 果 是 一 样 的， 只 不 过 后 者 至 少 要 进 行 两 次 键 查 询—— 如 果 键 不 存 在 的 话， 就 是 三 次， 用 setdefault 只 需 要 一 次 就 可 以 完 成 整 个 操 作。</div>
<div class='sectionHeading'>3.4.2　特殊方法 __missing__</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 2866</div><div class='noteText'>像 k in my_dict.keys() 这 种 操 作 在 Python 3 中 是 很 快 的， 而 且 即 便 映 射 类 型 对 象 很 庞 大 也 没 关 系。 这 是 因 为 dict.keys() 的 返 回 值 是 一 个“ 视 图”。 视 图 就 像 一 个 集 合， 而 且 跟 字 典 类 似 的 是， 在 视 图 里 查 找 一 个 元 素 的 速 度 很 快。</div>
<div class='sectionHeading'>3.5　字典的变种</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 2914</div><div class='noteText'>同， UserDict 是 让 用 户 继 承 写 子 类 的。</div>
<div class='sectionHeading'>3.6　子类化UserDict</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 2920</div><div class='noteText'>而 更 倾 向 于 从 UserDict 而 不 是 从 dict 继 承 的 主 要 原 因 是， 后 者 有 时 会 在 某 些 方 法 的 实 现 上 走 一 些 捷 径， 导 致 我 们 不 得 不 在 它 的 子 类 中 重 写 这 些 方 法， 但 是 UserDict 就 不 会 带 来 这 些 问 题。 5</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 2983</div><div class='noteText'>之 前 我 们 见 识 过 了 不 可 变 的 序 列 类 型， 那 有 没 有 不 可 变 的 字 典 类 型 呢？ 这 么 说 吧， 在 标 准 库 里 是 没 有 这 样 的 类 型 的， 但 是 可 以 用 替 身 来 代 替。</div>
<div class='sectionHeading'>3.7　不可变映射类型</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 2990</div><div class='noteText'>从 Python 3.3 开 始， types 模 块 中 引 入 了 一 个 封 装 类 名 叫 MappingProxyType。 如 果 给 这 个 类 一 个 映 射， 它 会 返 回 一 个 只 读 的 映 射 视 图。 虽 然 是 个 只 读 视 图， 但 是 它 是 动 态 的。 这 意 味 着 如 果 对 原 映 射 做 出 了 改 动， 我 们 通 过 这 个 视 图 可 以 观 察 到， 但 是 无 法 通 过 这 个 视 图 对 原 映 射 做 出 修 改。</div>
<div class='sectionHeading'>3.8　集合论</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 3017</div><div class='noteText'>set 和 它 的 不 可 变 的 姊 妹 类 型 frozenset 直 到 Python 2.3 才 首 次 以 模 块 的 形 式 出 现， 然 后 在 Python 2.6 中 它 们 升 级 成 为 内 置 类 型。</div>
<div class='sectionHeading'>3.8.1　集合字面量</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 3082</div><div class='noteText'>像 {1, 2, 3} 这 种 字 面 量 句 法 相 比 于 构 造 方 法（ set([ 1, 2, 3])） 要 更 快 且 更 易 读。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 3086</div><div class='noteText'>但 是 如 果 是 像 {1, 2, 3} 这 样 的 字 面 量， Python 会 利 用 一 个 专 门 的 叫 作 BUILD_SET 的 字 节 码 来 创 建 集 合。</div>
<div class='sectionHeading'>3.9.2　字典中的散列表</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 3473</div><div class='noteText'>内 置 的 hash() 方 法 可 以 用 于 所 有 的 内 置 类 型 对 象。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 3480</div><div class='noteText'>为 了 让 散 列 值 能 够 胜 任 散 列 表 索 引 这 一 角 色， 它 们 必 须 在 索 引 空 间 中 尽 量 分 散 开 来。 这 意 味 着 在 最 理 想 的 状 况 下， 越 是 相 似 但 不 相 等 的 对 象， 它 们 散 列 值 的 差 别 应 该 越 大。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 3524</div><div class='noteText'>另 外 在 插 入 新 值 时， Python 可 能 会 按 照 散 列 表 的 拥 挤 程 度 来 决 定 是 否 要 重 新 分 配 内 存 为 它 扩 容。 如 果 增 加 了 散 列 表 的 大 小， 那 散 列 值 所 占 的 位 数 和 用 作 索 引 的 位 数 都 会 随 之 增 加， 这 样 做 的 目 的 是 为 了 减 少 发 生 散 列 冲 突 的 概 率。</div>
<div class='sectionHeading'>3.9.3　dict的实现及其导致的结果</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 3557</div><div class='noteText'>字 典 在 内 存 上 的 开 销 巨 大</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 3558</div><div class='noteText'>由 于 字 典 使 用 了 散 列 表， 而 散 列 表 又 必 须 是 稀 疏 的， 这 导 致 它 在 空 间 上 的 效 率 低 下。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 3558</div><div class='noteText'>言， 如 果 你 需 要 存 放 数 量 巨 大 的 记 录， 那 么 放 在 由 元 组 或 是 具 名 元 组 构 成 的 列 表 中 会 是 比 较 好 的 选 择； 最 好 不 要 根 据 JSON 的 风 格， 用 由 字 典 组 成 的 列 表 来 存 放 这 些 记 录。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 3566</div><div class='noteText'>优 化 往 往 是 可 维 护 性 的 对 立 面。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 3571</div><div class='noteText'>键 的 次 序 取 决 于 添 加 顺 序</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 3572</div><div class='noteText'>当 往 dict 里 添 加 新 键 而 又 发 生 散 列 冲 突 的 时 候， 新 键 可 能 会 被 安 排 存 放 到 另 一 个 位 置。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 3599</div><div class='noteText'>往 字 典 里 添 加 新 键 可 能 会 改 变 已 有 键 的 顺 序</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 3605</div><div class='noteText'>由 此 可 知， 不 要 对 字 典 同 时 进 行 迭 代 和 修 改。</div>
<div class='sectionHeading'>3.9.4　set的实现以及导致的结果</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 3619</div><div class='noteText'>集 合 里 的 元 素 必 须 是 可 散 列 的。 集 合 很 消 耗 内 存。 可 以 很 高 效 地 判 断 元 素 是 否 存 在 于 某 个 集 合。 元 素 的 次 序 取 决 于 被 添 加 到 集 合 里 的 次 序。 往 集 合 里 添 加 元 素， 可 能 会 改 变 集 合 里 已 有 元 素 的 次 序。</div>
<div class='sectionHeading'>3.11　延伸阅读</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 3668</div><div class='noteText'>我 的 朋 友 Geraldo Cohen 曾 经 说 过， Python 的 特 点 是“ 简 单 而 正 确”。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 3689</div><div class='noteText'>PHP 和 Ruby 的 散 列 语 法 借 鉴 了 Perl， 它 们 都 用 = &gt; 作 为 键 和 值 的 连 接。 JavaScript 则 从 Python 那 儿 偷 师， 使 用 了 :。</div>
<div class='sectionHeading'>4.2　字节概要</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 3836</div><div class='noteText'>使 用 缓 冲 类 对 象 构 建 二 进 制 序 列 是 一 种 低 层 操 作， 可 能 涉 及 类 型 转 换。</div>
<div class='sectionHeading'>4.5　处理文本文件</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 4084</div><div class='noteText'>处 理 文 本 的 最 佳 实 践 是“ Unicode 三 明 治”（ 如 图 4-2 所 示）。 4 意 思 是， 要 尽 早 把 输 入（ 例 如 读 取 文 件 时） 的 字 节 序 列 解 码 成 字 符 串。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 4085</div><div class='noteText'>这 种 三 明 治 中 的“ 肉 片” 是 程 序 的 业 务 逻 辑， 在 这 里 只 能 处 理 字 符 串 对 象。 在 其 他 处 理 过 程 中， 一 定 不 能 编 码 或 解 码。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 4086</div><div class='noteText'>对 输 出 来 说， 则 要 尽 量 晚 地 把 字 符 串 编 码 成 字 节 序 列。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 4105</div><div class='noteText'>写 入 文 件 时 指 定 了 UTF-8 编 码， 但 是 读 取 文 件 时 没 有 这 么 做， 因 此 Python 假 定 要 使 用 系 统 默 认 的 编 码（ Windows 1252）， 于 是 文 件 的 最 后 一 个 字 节 解 码 成 了 字 符 'Ã ©'， 而 不 是 'é'。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 4112</div><div class='noteText'>需 要 在 多 台 设 备 中 或 多 种 场 合 下 运 行 的 代 码， 一 定 不 能 依 赖 默 认 编 码。 打 开 文 件 时 始 终 应 该 明 确 传 入 encoding = 参 数， 因 为 不 同 的 设 备 使 用 的 默 认 编 码 可 能 不 同， 有 时 隔 一 天 也 会 发 生 变 化。</div>
<div class='sectionHeading'>编码默认值：一团糟</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 4237</div><div class='noteText'>关 于 编 码 默 认 值 的 最 佳 建 议 是： 别 依 赖 默 认 值。</div>
<div class='sectionHeading'>5.5　用户定义的可调用类型</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 4985</div><div class='noteText'>装 饰 器 就 是 这 样。 装 饰 器 必 须 是 函 数， 而 且 有 时 要 在 多 次 调 用 之 间“ 记 住” 某 些 事 [ 例 如 备 忘（ memoization）， 即 缓 存 消 耗 大 的 计 算 结 果， 供 后 面 使 用 ]。</div>
<div class='sectionHeading'>5.7　从定位参数到仅限关键字参数</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 5103</div><div class='noteText'>仅 限 关 键 字 参 数 是 Python 3 新 增 的 特 性。 在 示 例 5-10 中， cls 参 数 只 能 通 过 关 键 字 参 数 指 定， 它 一 定 不 会 捕 获 未 命 名 的 定 位 参 数。 定 义 函 数 时 若 想 指 定 仅 限 关 键 字 参 数， 要 把 它 们 放 到 前 面 有 * 的 参 数 后 面。 如 果 不 想 支 持 数 量 不 定 的 定 位 参 数， 但 是 想 支 持 仅 限 关 键 字 参 数， 在 签 名 中 放 一 个 *， 如 下 所 示：</div>
<div class='sectionHeading'>5.8　获取关于参数的信息</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 5122</div><div class='noteText'>发 现 它 需 要 一 个 名 为 person 的 参 数， 然 后 从 请 求 中 获 取 那 个 名 称 对 应 的 参 数， 将 其 传 给 hello 函 数， 因 此 程 序 员 根 本 不 用 触 碰 请 求 对 象。</div>
<div class='sectionHeading'>5.9　函数注解</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 5274</div><div class='noteText'>注 解 对 Python 解 释 器 没 有 任 何 意 义。 注 解 只 是 元 数 据， 可 以 供 IDE、 框 架 和 装 饰 器 等 工 具 使 用。 写 作 本 书 时， 标 准 库 中 还 没 有 什 么 会 用 到 这 些 元 数 据， 唯 有 inspect.signature() 函 数 知 道 怎 么 提 取 注 解，</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 5292</div><div class='noteText'>函 数 注 解 的 最 大 影 响 或 许 不 是 让 Bobo 等 框 架 自 动 设 置， 而 是 为 IDE 和 lint 程 序 等 工 具 中 的 静 态 类 型 检 查 功 能 提 供 额 外 的 类 型 信 息。</div>
<div class='sectionHeading'>5.10.2　使用functools.partial冻结参数</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 5410</div><div class='noteText'>余 下 的 函 数 中， 最 有 用 的 是 partial 及 其 变 体， partialmethod。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 5463</div><div class='noteText'>functools.partialmethod 函 数（ Python 3.4 新 增） 的 作 用 与 partial 一 样， 不 过 是 用 于 处 理 方 法 的。</div>
<div class='sectionHeading'>5.12　延伸阅读</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 5538</div><div class='noteText'>它 们 的 设 计 者 没 有 耐 心 去 精 确 实 现 林 奈 层 次 结 构； 设 计 者 按 照 自 己 的 意 愿 从 别 处 借 鉴 特 性， 创 建 出 完 全 无 视 过 往 概 念 的 大 杂 烩。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 5540</div><div class='noteText'>不 要 试 图 把 语 言 归 为 某 一 类； 相 反， 把 它 们 视 作 特 性 的 聚 合 更 有 用。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 5558</div><div class='noteText'>除 了 匿 名 函 数 句 法 上 的 限 制 之 外， 影 响 函 数 式 编 程 惯 用 法 在 Python 中 广 泛 使 用 的 最 大 障 碍 是 缺 少 尾 递 归 消 除（ tail-recursion elimination）， 这 是 一 项 优 化 措 施， 在 函 数 的 定 义 体“ 末 尾” 递 归 调 用， 从 而 提 高 计 算 函 数 的 内 存 使 用 效 率。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 5570</div><div class='noteText'>顺 便 说 一 下， promise 对 象、 期 物（ future） 和 deferred 对 象 是 现 代 异 步 API 中 使 用 的 概 念。 把 它 们 与 协 程 结 合 起 来， 能 避 免 掉 入“ 回 调 地 狱”。 18.5 节 会 说 明 如 何 不 用 回 调 来 做 异 步 编 程。</div>
<div class='sectionHeading'>第 6 章　使用一等函数实现设计模式</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 5575</div><div class='noteText'>符 合 模 式 并 不 表 示 做 得 对。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 5581</div><div class='noteText'>其 中 有 16 个 在 动 态 语 言 中“ 不 见 了， 或 者 简 化 了”（ 参 见 第 9 张 幻 灯 片）。 他 讨 论 的 是 Lisp 和 Dylan， 不 过 很 多 相 关 的 动 态 特 性 在 Python 中 也 能 找 到。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 5583</div><div class='noteText'>《设 计 模 式： 可 复 用 面 向 对 象 软 件 的 基 础》 的 作 者 在 引 言 中 承 认， 所 用 的 语 言 决 定 了 哪 些 模 式 可 用：</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 5589</div><div class='noteText'>Norvig 建 议 在 有 一 等 函 数 的 语 言 中 重 新 审 视“ 策 略”“ 命 令”“ 模 板 方 法” 和“ 访 问 者” 模 式。</div>
<div class='sectionHeading'>6.1.2　使用函数实现“策略”模式</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 5735</div><div class='noteText'>在 复 杂 的 情 况 下， 需 要 具 体 策 略 维 护 内 部 状 态 时， 可 能 需 要 把“ 策 略” 和“ 享 元” 模 式 结 合 起 来。</div>
<div class='sectionHeading'>6.1.4　找出模块中的全部策略</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 5780</div><div class='noteText'>对 函 数 或 方 法 来 说， 是 指 定 义 它 们 的 模 块， 而 不 是 调 用 它 们 的 模 块）。</div>
<div class='sectionHeading'>6.4　延伸阅读</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 5886</div><div class='noteText'>《Python 高 级 编 程》（ Tarek Ziadé 著） 是 市 面 上 最 好 的 Python 中 级 书，</div>
<div class='sectionHeading'>第 7 章　函数装饰器和闭包</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 5928</div><div class='noteText'>nonlocal 是 新 近 出 现 的 保 留 关 键 字， 在 Python 3.0 中 引 入。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 5930</div><div class='noteText'>如 果 你 想 自 己 实 现 函 数 装 饰 器， 那 就 必 须 了 解 闭 包 的 方 方 面 面， 因 此 也 就 需 要 知 道 nonlocal。</div>
<div class='sectionHeading'>7.1　装饰器基础知识</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 5971</div><div class='noteText'>第 二 个 特 性 是， 装 饰 器 在 加 载 模 块 时 立 即 执 行。</div>
<div class='sectionHeading'>7.2　Python何时执行装饰器</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 5972</div><div class='noteText'>装 饰 器 的 一 个 关 键 特 性 是， 它 们 在 被 装 饰 的 函 数 定 义 之 后 立 即 运 行。 这 通 常 是 在 导 入 时（ 即 Python 加 载 模 块 时），</div>
<div class='sectionHeading'>7.5　闭包</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6151</div><div class='noteText'>闭 包 指 延 伸 了 作 用 域 的 函 数， 其 中 包 含 函 数 定 义 体 中 引 用、 但 是 不 在 定 义 体 中 定 义 的 非 全 局 变 量。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6152</div><div class='noteText'>关 键 是 它 能 访 问 定 义 体 之 外 定 义 的 非 全 局 变 量。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6223</div><div class='noteText'>只 有 嵌 套 在 其 他 函 数 中 的 函 数 才 可 能 需 要 处 理 不 在 全 局 作 用 域 中 的 外 部 变 量。</div>
<div class='sectionHeading'>7.6　nonlocal声明</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6238</div><div class='noteText'>当 count 是 数 字 或 任 何 不 可 变 类 型 时， count + = 1 语 句 的 作 用 其 实 与 count = count + 1 一 样。 因 此， 我 们 在 averager 的 定 义 体 中 为 count 赋 值 了， 这 会 把 count 变 成 局 部 变 量。 total 变 量 也 受 这 个 问 题 影 响。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6248</div><div class='noteText'>但 是 对 数 字、 字 符 串、 元 组 等 不 可 变 类 型 来 说， 只 能 读 取， 不 能 更 新。 如 果 尝 试 重 新 绑 定， 例 如 count = count + 1， 其 实 会 隐 式 创 建 局 部 变 量 count。 这 样， count 就 不 是 自 由 变 量 了， 因 此 不 会 保 存 在 闭 包 中。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6252</div><div class='noteText'>为 了 解 决 这 个 问 题， Python 3 引 入 了 nonlocal 声 明。 它 的 作 用 是 把 变 量 标 记 为 自 由 变 量， 即 使 在 函 数 中 为 变 量 赋 予 新 值 了， 也 会 变 成 自 由 变 量。 如 果 为 nonlocal 声 明 的 变 量 赋 予 新 值， 闭 包 中 保 存 的 绑 定 会 更 新。</div>
<div class='sectionHeading'>工作原理</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6322</div><div class='noteText'>这 是 装 饰 器 的 典 型 行 为： 把 被 装 饰 的 函 数 替 换 成 新 函 数， 二 者 接 受 相 同 的 参 数， 而 且（ 通 常） 返 回 被 装 饰 的 函 数 本 该 返 回 的 值， 同 时 还 会 做 些 额 外 操 作。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6328</div><div class='noteText'>示 例 7-15 中 实 现 的 clock 装 饰 器 有 几 个 缺 点： 不 支 持 关 键 字 参 数， 而 且 遮 盖 了 被 装 饰 函 数 的 __name__ 和 __doc__ 属 性。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6331</div><div class='noteText'>使 用 functools.wraps 装 饰 器 把 相 关 的 属 性 从 func 复 制 到 clocked 中。 此 外， 这 个 新 版 还 能 正 确 处 理 关 键 字 参 数。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6345</div><div class='noteText'>functools.wraps 只 是 标 准 库 中 拿 来 即 用 的 装 饰 器 之 一。</div>
<div class='sectionHeading'>7.8　标准库中的装饰器</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6352</div><div class='noteText'>另 一 个 常 见 的 装 饰 器 是 functools.wraps， 它 的 作 用 是 协 助 构 建 行 为 良 好 的 装 饰 器。</div>
<div class='sectionHeading'>7.8.1　使用functools.lru_cache做备忘</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6359</div><div class='noteText'>它 实 现 了 备 忘（ memoization） 功 能。 这 是 一 项 优 化 技 术， 它 把 耗 时 的 函 数 的 结 果 保 存 起 来， 避 免 传 入 相 同 的 参 数 时 重 复 计 算。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6401</div><div class='noteText'>除 了 优 化 递 归 算 法 之 外， lru_cache 在 从 Web 中 获 取 信 息 的 应 用 中 也 能 发 挥 巨 大 作 用。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6414</div><div class='noteText'>它 的 所 有 参 数 都 必 须 是 可 散 列 的。</div>
<div class='sectionHeading'>7.8.2　单分派泛函数</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6452</div><div class='noteText'>Python 3.4 新 增 的 functools.singledispatch 装 饰 器 可 以 把 整 体 方 案 拆 分 成 多 个 模 块， 甚 至 可 以 为 你 无 法 修 改 的 类 提 供 专 门 的 函 数。 使 用 @singledispatch 装 饰 的 普 通 函 数 会 变 成 泛 函 数（ generic function）： 根 据 第 一 个 参 数 的 类 型， 以 不 同 方 式 执 行 相 同 操 作 的 一 组 函 数。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6476</div><div class='noteText'>专 门 函 数 的 名 称 无 关 紧 要；_ 是 个 不 错 的 选 择， 简 单 明 了。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6487</div><div class='noteText'>使 用 抽 象 基 类 检 查 类 型， 可 以 让 代 码 支 持 这 些 抽 象 基 类 现 有 和 未 来 的 具 体 子 类 或 虚 拟 子 类。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6493</div><div class='noteText'>singledispatch 是 经 过 深 思 熟 虑 之 后 才 添 加 到 标 准 库 中 的， 它 提 供 的 特 性 很 多， 这 里 无 法 一 一 说 明。 这 个 机 制 最 好 的 文 档 是“ PEP 443 — Single-dispatch generic functions”。</div>
<div class='sectionHeading'>7.11　本章小结</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6676</div><div class='noteText'>若 想 真 正 理 解 装 饰 器， 需 要 区 分 导 入 时 和 运 行 时， 还 要 知 道 变 量 作 用 域、 闭 包 和 新 增 的 nonlocal 声 明。 掌 握 闭 包 和 nonlocal 不 仅 对 构 建 装 饰 器 有 帮 助， 还 能 协 助 你 在 构 建 GUI 程 序 时 面 向 事 件 编 程， 或 者 使 用 回 调 处 理 异 步 I/ O。</div>
<div class='sectionHeading'>7.12　延伸阅读</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6743</div><div class='noteText'>一 书 中 对“ 装 饰 器” 模 式 的 一 般 描 述：“ 动 态 地 给 一 个 对 象 添 加 一 些 额 外 的 职 责。 就 扩 展 功 能 而 言， 装 饰 器 模 式 比 子 类 化 更 灵 活。”</div>
<div class='sectionHeading'>第 8 章　对象引用、可变性和垃圾回收</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6769</div><div class='noteText'>元 组 是 不 可 变 的， 但 是 其 中 的 值 可 以 改 变， 之 后 就 引 申 到 浅 复 制 和 深 复 制。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6770</div><div class='noteText'>可 变 的 参 数 默 认 值 导 致 的 问 题， 以 及 如 何 安 全 地 处 理 函 数 的 调 用 者 传 入 的 可 变 参 数。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6771</div><div class='noteText'>讨 论 垃 圾 回 收、 del 命 令， 以 及 如 何 使 用 弱 引 用“ 记 住” 对 象， 而 无 需 对 象 本 身 存 在。</div>
<div class='sectionHeading'>8.1　变量不是盒子</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6777</div><div class='noteText'>Python 变 量 类 似 于 Java 中 的 引 用 式 变 量，</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6778</div><div class='noteText'>因 此 最 好 把 它 们 理 解 为 附 加 在 对 象 上 的 标 注。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6803</div><div class='noteText'>为 了 理 解 Python 中 的 赋 值 语 句， 应 该 始 终 先 读 右 边。 对 象 在 右 边 创 建 或 获 取， 在 此 之 后 左 边 的 变 量 才 会 绑 定 到 对 象 上， 这 就 像 为 对 象 贴 上 标 注。 忘 掉 盒 子 吧！</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6804</div><div class='noteText'>因 为 变 量 只 不 过 是 标 注， 所 以 无 法 阻 止 为 对 象 贴 上 多 个 标 注。 贴 的 多 个 标 注， 就 是 别 名。</div>
<div class='sectionHeading'>8.2　标识、相等性和别名</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6846</div><div class='noteText'>每 个 变 量 都 有 标 识、 类 型 和 值。 对 象 一 旦 创 建， 它 的 标 识 绝 不 会 变； 你 可 以 把 标 识 理 解 为 对 象 在 内 存 中 的 地 址。 is 运 算 符 比 较 两 个 对 象 的 标 识； id() 函 数 返 回 对 象 标 识 的 整 数 表 示。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6848</div><div class='noteText'>对 象 ID 的 真 正 意 义 在 不 同 的 实 现 中 有 所 不 同。 在 CPython 中， id() 返 回 对 象 的 内 存 地 址， 但 是 在 其 他 Python 解 释 器 中 可 能 是 别 的 值。 关 键 是， ID 一 定 是 唯 一 的 数 值 标 注， 而 且 在 对 象 的 生 命 周 期 中 绝 不 会 变。</div>
<div class='sectionHeading'>8.2.2　元组的相对不可变性</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6880</div><div class='noteText'>元 组 的 不 可 变 性 其 实 是 指 tuple 数 据 结 构 的 物 理 内 容（ 即 保 存 的 引 用） 不 可 变， 与 引 用 的 对 象 无 关。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6882</div><div class='noteText'>而 str、 bytes 和 array.array 等 单 一 类 型 序 列 是 扁 平 的， 它 们 保 存 的 不 是 引 用， 而 是 在 连 续 的 内 存 中 保 存 数 据 本 身（ 字 符、 字 节 和 数 字）。</div>
<div class='sectionHeading'>8.3　默认做浅复制</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 6964</div><div class='noteText'>浅 复 制 容 易 操 作， 但 是 得 到 的 结 果 可 能 并 不 是 你 想 要 的。 接 下 来 说 明 如 何 做 深 复 制。</div>
<div class='sectionHeading'>为任意对象做深复制和浅复制</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7003</div><div class='noteText'>一 般 来 说， 深 复 制 不 是 件 简 单 的 事。 如 果 对 象 有 循 环 引 用， 那 么 这 个 朴 素 的 算 法 会 进 入 无 限 循 环。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7004</div><div class='noteText'>deepcopy 函 数 会 记 住 已 经 复 制 的 对 象， 因 此 能 优 雅 地 处 理 循 环 引 用，</div>
<div class='sectionHeading'>8.4　函数的参数作为引用时</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7019</div><div class='noteText'>Python 唯 一 支 持 的 参 数 传 递 模 式 是 共 享 传 参（ call by sharing）。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7023</div><div class='noteText'>这 种 方 案 的 结 果 是， 函 数 可 能 会 修 改 作 为 参 数 传 入 的 可 变 对 象， 但 是 无 法 修 改 那 些 对 象 的 标 识（ 即 不 能 把 一 个 对 象 替 换 成 另 一 个 对 象）。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7032</div><div class='noteText'>数 字 x 没 变。</div>
<div class='sectionHeading'>8.4.1　不要使用可变类型作为参数的默认值</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7036</div><div class='noteText'>不 要 使 用 可 变 类 型 作 为 参 数 的 默 认 值</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7077</div><div class='noteText'>问 题 在 于， 没 有 指 定 初 始 乘 客 的 HauntedBus 实 例 会 共 享 同 一 个 乘 客 列 表。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7094</div><div class='noteText'>可 变 默 认 值 导 致 的 这 个 问 题 说 明 了 为 什 么 通 常 使 用 None 作 为 接 收 可 变 值 的 参 数 的 默 认 值。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7099</div><div class='noteText'>如 果 passengers 不 是 None， 正 确 的 实 现 会 把 passengers 的 副 本 赋 值 给 self.passengers。</div>
<div class='sectionHeading'>8.4.2　防御可变参数</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7103</div><div class='noteText'>如 果 定 义 的 函 数 接 收 可 变 参 数，</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7155</div><div class='noteText'>除 非 这 个 方 法 确 实 想 修 改 通 过 参 数 传 入 的 对 象， 否 则 在 类 中 直 接 把 参 数 赋 值 给 实 例 变 量 之 前 一 定 要 三 思， 因 为 这 样 会 为 参 数 对 象 创 建 别 名。 如 果 不 确 定， 那 就 创 建 副 本。 这 样 客 户 会 少 些 麻 烦。</div>
<div class='sectionHeading'>8.5　del和垃圾回收</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7160</div><div class='noteText'>del 语 句 删 除 名 称， 而 不 是 对 象。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7161</div><div class='noteText'>del 命 令 可 能 会 导 致 对 象 被 当 作 垃 圾 回 收， 但 是 仅 当 删 除 的 变 量 保 存 的 是 对 象 的 最 后 一 个 引 用， 或 者 无 法 得 到 对 象 时。 2 重 新 绑 定 也 可 能 会 导 致 对 象 的 引 用 数 量 归 零， 导 致 对 象 被 销 毁。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7172</div><div class='noteText'>在 CPython 中， 垃 圾 回 收 使 用 的 主 要 算 法 是 引 用 计 数。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7175</div><div class='noteText'>CPython 　 2.0 增 加 了 分 代 垃 圾 回 收 算 法， 用 于 检 测 引 用 循 环 中 涉 及 的 对 象 组—— 如 果 一 组 对 象 之 间 全 是 相 互 引 用， 即 使 再 出 色 的 引 用 方 式 也 会 导 致 组 中 的 对 象 不 可 获 取。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7177</div><div class='noteText'>Python 的 其 他 实 现 有 更 复 杂 的 垃 圾 回 收 程 序， 而 且 不 依 赖 引 用 计 数， 这 意 味 着， 对 象 的 引 用 数 量 为 零 时 可 能 不 会 立 即 调 用 __del__ 方 法。</div>
<div class='sectionHeading'>8.6　弱引用</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7212</div><div class='noteText'>弱 引 用 不 会 增 加 对 象 的 引 用 数 量。 引 用 的 目 标 对 象 称 为 所 指 对 象（ referent）。 因 此 我 们 说， 弱 引 用 不 会 妨 碍 所 指 对 象 被 当 作 垃 圾 回 收。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7220</div><div class='noteText'>微 观 管 理 内 存 时， 往 往 会 得 到 意 外 的 结 果， 因 为 不 明 显 的 隐 式 赋 值 会 为 对 象 创 建 新 引 用。 控 制 台 中 的 _ 变 量 是 一 例。 调 用 跟 踪 对 象 也 常 导 致 意 料 之 外 的 引 用。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7241</div><div class='noteText'>_ 绑 定 到 结 果 值 False。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7247</div><div class='noteText'>weakref 模 块 的 文 档 指 出， weakref.ref 类 其 实 是 低 层 接 口， 供 高 级 用 途 使 用， 多 数 程 序 最 好 使 用 weakref 集 合 和 finalize。 也 就 是 说， 应 该 使 用 WeakKeyDictionary、 WeakValueDictionary、 WeakSet 和 finalize（ 在 内 部 使 用 弱 引 用）， 不 要 自 己 动 手 创 建 并 处 理 weakref.ref 实 例。</div>
<div class='sectionHeading'>8.6.1　WeakValueDictionary简介</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7259</div><div class='noteText'>WeakValueDictionary 类 实 现 的 是 一 种 可 变 映 射， 里 面 的 值 是 对 象 的 弱 引 用。 被 引 用 的 对 象 在 程 序 中 的 其 他 地 方 被 当 作 垃 圾 回 收 后， 对 应 的 键 会 自 动 从 WeakValueDictionary 中 删 除。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7261</div><div class='noteText'>WeakValueDictionary 经 常 用 于 缓 存。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7305</div><div class='noteText'>（WeakKeyDictionary 实 例） 可 以 为 应 用 中 其 他 部 分 拥 有 的 对 象 附 加 数 据， 这 样 就 无 需 为 对 象 添 加 属 性。 这 对 覆 盖 属 性 访 问 权 限 的 对 象 尤 其 有 用。</div>
<div class='sectionHeading'>8.6.2　弱引用的局限</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7314</div><div class='noteText'>不 是 每 个 Python 对 象 都 可 以 作 为 弱 引 用 的 目 标（ 或 称 所 指 对 象）。 基 本 的 list 和 dict 实 例 不 能 作 为 所 指 对 象，</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7326</div><div class='noteText'>这 些 局 限 基 本 上 是 CPython 的 实 现 细 节， 在 其 他 Python 解 释 器 中 情 况 可 能 不 一 样。 这 些 局 限 是 内 部 优 化 导 致 的 结 果，</div>
<div class='sectionHeading'>8.7　Python对不可变类型施加的把戏</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7332</div><div class='noteText'>对 元 组 t 来 说， t[:] 不 创 建 副 本， 而 是 返 回 同 一 个 对 象 的 引 用。 此 外， tuple( t) 获 得 的 也 是 同 一 个 元 组 的 引 用。</div>
<div class='sectionHeading'>8.9　延伸阅读</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7451</div><div class='noteText'>在“ 纯” 函 数 式 编 程 中， 所 有 数 据 都 是 不 可 变 的， 如 果 为 集 合 追 加 元 素， 那 么 其 实 会 创 建 新 的 集 合。 然 而， Python 不 是 函 数 式 语 言， 更 别 提 纯 不 纯 了。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7469</div><div class='noteText'>在 任 何 情 况 下， 包 括 CPython， 最 好 显 式 关 闭 文 件； 而 关 闭 文 件 的 最 可 靠 方 式 是 使 用 with 语 句， 它 能 保 证 文 件 一 定 会 被 关 闭， 即 使 打 开 文 件 时 抛 出 了 异 常 也 无 妨。 使 用 with， 上 述 代 码 片 段 变 成 了：</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7480</div><div class='noteText'>在 Python 中， 函 数 得 到 参 数 的 副 本， 但 是 参 数 始 终 是 引 用。</div>
<div class='sectionHeading'>第 9 章　符合Python风格的对象</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7504</div><div class='noteText'>绝 对 不 要 使 用 两 个 前 导 下 划 线， 这 是 很 烦 人 的 自 私 行 为。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7513</div><div class='noteText'>支 持 用 于 生 成 对 象 其 他 表 示 形 式 的 内 置 函 数（ 如 repr()、 bytes()， 等 等）</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7515</div><div class='noteText'>使 用 一 个 类 方 法 实 现 备 选 构 造 方 法</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7516</div><div class='noteText'>扩 展 内 置 的 format() 函 数 和 str.format() 方 法 使 用 的 格 式 微 语 言</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7518</div><div class='noteText'>实 现 只 读 属 性</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7518</div><div class='noteText'>把 对 象 变 为 可 散 列 的， 以 便 在 集 合 中 及 作 为 dict 的 键 使 用</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7520</div><div class='noteText'>利 用 __slots__ 节 省 内 存</div>
<div class='sectionHeading'>9.2　再谈向量类</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7620</div><div class='noteText'>可 迭 代 的</div>
<div class='sectionHeading'>9.4　classmethod与staticmethod</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7672</div><div class='noteText'>定 义 操 作 类， 而 不 是 操 作 实 例 的 方 法。 classmethod 改 变 了 调 用 方 法 的 方 式， 因 此 类 方 法 的 第 一 个 参 数 是 类 本 身， 而 不 是 实 例。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7674</div><div class='noteText'>classmethod 最 常 见 的 用 途 是 定 义 备 选 构 造 方 法，</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7681</div><div class='noteText'>其 实， 静 态 方 法 就 是 普 通 的 函 数， 只 是 碰 巧 在 类 的 定 义 体 中， 而 不 是 在 模 块 层 定 义。</div>
<div class='sectionHeading'>9.6　可散列的Vector2d</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7830</div><div class='noteText'>为 了 把 Vector2d 实 例 变 成 可 散 列 的， 必 须 使 用 __hash__ 方 法（ 还 需 要 __eq__ 方 法， 前 面 已 经 实 现 了）。 此 外， 还 要 让 向 量 不 可 变， 详 情 参 见 第 3 章 的 附 注 栏“ 什 么 是 可 散 列 的 数 据 类 型”。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7853</div><div class='noteText'>❷ @property 装 饰 器 把 读 值 方 法 标 记 为 特 性。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7865</div><div class='noteText'>注 意， 我 们 让 这 些 向 量 不 可 变 是 有 原 因 的， 因 为 这 样 才 能 实 现 __hash__ 方 法。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7867</div><div class='noteText'>因 为 相 等 的 对 象 应 该 具 有 相 同 的 散 列 值。 根 据 特 殊 方 法 __hash__ 的 文 档， 最 好 使 用 位 运 算 符 异 或（ ^） 混 合 各 分 量 的 散 列 值—— 我 们 会 这 么 做。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7875</div><div class='noteText'>return hash( self.x) ^ hash( self.y)</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7940</div><div class='noteText'>我 们 将 讨 论 Python 对 私 有 属 性（ 带 两 个 下 划 线 前 缀 的 属 性， 如 self.__x） 的 设 计 方 式 及 其 缺 点。</div>
<div class='sectionHeading'>9.7　Python的私有属性和“受保护的”属性</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7943</div><div class='noteText'>但 是 Python 有 个 简 单 的 机 制， 能 避 免 子 类 意 外 覆 盖“ 私 有” 属 性。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7951</div><div class='noteText'>为 了 避 免 这 种 情 况， 如 果 以 __mood 的 形 式（ 两 个 前 导 下 划 线， 尾 部 没 有 或 最 多 有 一 个 下 划 线） 命 名 实 例 属 性， Python 会 把 属 性 名 存 入 实 例 的 __dict__ 属 性 中， 而 且 会 在 前 面 加 上 一 个 下 划 线 和 类 名。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7957</div><div class='noteText'>这 个 语 言 特 性 叫 名 称 改 写（</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7963</div><div class='noteText'>名 称 改 写 是 一 种 安 全 措 施， 不 能 保 证 万 无 一 失： 它 的 目 的 是 避 免 意 外 访 问， 不 能 防 止 故 意 做 错 事（</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7972</div><div class='noteText'>有 些 人 不 喜 欢 这 种 句 法， 他 们 约 定 使 用 一 个 下 划 线 前 缀 编 写“ 受 保 护” 的 属 性（ 如 self._x）。 批 评 使 用 两 个 下 划 线 这 种 改 写 机 制 的 人 认 为， 应 该 使 用 命 名 约 定 来 避 免 意 外 覆 盖 属 性。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 7975</div><div class='noteText'>绝 对 不 要 使 用 两 个 前 导 下 划 线， 这 是 很 烦 人 的 自 私 行 为。 如 果 担 心 名 称 冲 突， 应 该 明 确 使 用 一 种 名 称 改 写 方 式（ 如 _MyThing_blahblah）。 这 其 实 与 使 用 双 下 划 线 一 样， 不 过 自 己 定 的 规 则 比 双 下 划 线 易 于 理 解。 7</div>
<div class='sectionHeading'>9.8　使用 __slots__ 类属性节省空间</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8005</div><div class='noteText'>通 过 __slots__ 类 属 性， 能 节 省 大 量 内 存， 方 法 是 让 解 释 器 在 元 组 中 存 储 实 例 属 性， 而 不 用 字 典。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8007</div><div class='noteText'>继 承 自 超 类 的 __slots__ 属 性 没 有 效 果。 Python 只 会 使 用 各 个 类 中 定 义 的 __slots__ 属 性。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8009</div><div class='noteText'>定 义 __slots__ 的 方 式 是， 创 建 一 个 类 属 性， 使 用 __slots__ 这 个 名 字， 并 把 它 的 值 设 为 一 个 字 符 串 构 成 的 可 迭 代 对 象， 其 中 各 个 元 素 表 示 各 个 实 例 属 性。 我 喜 欢 使 用 元 组， 因 为 这 样 定 义 的 __slots__ 中 所 含 的 信 息 不 会 变 化，</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8017</div><div class='noteText'>__slots__ = ('__x', '__y')</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8019</div><div class='noteText'>在 类 中 定 义 __slots__ 属 性 的 目 的 是 告 诉 解 释 器：“ 这 个 类 中 的 所 有 实 例 属 性 都 在 这 儿 了！” 这 样， Python 会 在 各 个 实 例 中 使 用 类 似 元 组 的 结 构 存 储 实 例 变 量， 从 而 避 免 使 用 消 耗 内 存 的 __dict__ 属 性。 如 果 有 数 百 万 个 实 例 同 时 活 动， 这 样 做 能 节 省 大 量 内 存。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8047</div><div class='noteText'>在 类 中 定 义 __slots__ 属 性 之 后， 实 例 不 能 再 有 __slots__ 中 所 列 名 称 之 外 的 其 他 属 性。 这 只 是 一 个 副 作 用， 不 是 __slots__ 存 在 的 真 正 原 因。 不 要 使 用 __slots__ 属 性 禁 止 类 的 用 户 新 增 实 例 属 性。__slots__ 是 用 于 优 化 的， 不 是 为 了 约 束 程 序 员。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8057</div><div class='noteText'>这 取 决 于 各 个 实 例 的 静 态 属 性 和 动 态 属 性 的 数 量 及 其 用 法。 粗 心 的 优 化 甚 至 比 提 早 优 化 还 糟 糕。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8061</div><div class='noteText'>如 果 类 中 定 义 了 __slots__ 属 性， 而 且 想 把 实 例 作 为 弱 引 用 的 目 标， 那 么 要 把 '__weakref__' 添 加 到 __slots__ 中。</div>
<div class='sectionHeading'>__slots__ 的问题</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8072</div><div class='noteText'>每 个 子 类 都 要 定 义 __slots__ 属 性， 因 为 解 释 器 会 忽 略 继 承 的 __slots__ 属 性。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8077</div><div class='noteText'>如 果 不 把 '__weakref__' 加 入 __slots__， 实 例 就 不 能 作 为 弱 引 用 的 目 标。</div>
<div class='sectionHeading'>9.9　覆盖类属性</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8084</div><div class='noteText'>Python 有 个 很 独 特 的 特 性： 类 属 性 可 用 于 为 实 例 属 性 提 供 默 认 值。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8091</div><div class='noteText'>如 果 为 不 存 在 的 实 例 属 性 赋 值， 会 新 建 实 例 属 性。 假 如 我 们 为 typecode 实 例 属 性 赋 值， 那 么 同 名 类 属 性 不 受 影 响。 然 而， 自 此 之 后， 实 例 读 取 的 self.typecode 是 实 例 属 性 typecode， 也 就 是 把 同 名 类 属 性 遮 盖 了。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8119</div><div class='noteText'>如 果 想 修 改 类 属 性 的 值， 必 须 直 接 在 类 上 修 改， 不 能 通 过 实 例 修 改。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8124</div><div class='noteText'>类 属 性 是 公 开 的， 因 此 会 被 子 类 继 承， 于 是 经 常 会 创 建 一 个 子 类， 只 用 于 定 制 类 的 数 据 属 性。 Django 基 于 类 的 视 图 就 大 量 使 用 了 这 个 技 术。</div>
<div class='sectionHeading'>9.10　本章小结</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8194</div><div class='noteText'>要 构 建 符 合 Python 风 格 的 对 象， 就 要 观 察 真 正 的 Python 对 象 的 行 为。</div>
<div class='sectionHeading'>第 10 章　序列的修改、散列和切片</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8293</div><div class='noteText'>具 体 检 查 什 么 取 决 于 你 想 使 用 语 言 的 哪 些 行 为。（</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8309</div><div class='noteText'>把 协 议 当 作 正 式 接 口。 我 们 将 说 明 协 议 和 鸭 子 类 型 之 间 的 关 系， 以 及 对 自 定 义 类 型 的 实 际 影 响。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8313</div><div class='noteText'>一 个 关 键 的 相 关 指 标 是 余 弦 相 关 性（ 即 查 询 向 量 与 文 档 向 量 夹 角 的 余 弦）。 夹 角 越 小， 余 弦 值 越 趋 近 于 1， 文 档 与 查 询 的 相 关 性 就 越 大。</div>
<div class='sectionHeading'>10.2　Vector类第1版：与Vector2d类兼容</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8389</div><div class='noteText'>我 使 用 reprlib.repr 的 方 式 需 要 做 些 说 明。 这 个 函 数 用 于 生 成 大 型 结 构 或 递 归 结 构 的 安 全 表 示 形 式， 它 会 限 制 输 出 字 符 串 的 长 度， 用 '...' 表 示 截 断 的 部 分。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8416</div><div class='noteText'>两 个 构 造 方 法 不 兼 容， 因 此 不 建 议 继 承。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8418</div><div class='noteText'>以 此 实 现 序 列 协 议。 接 下 来， 我 们 先 讨 论 协 议 这 个 术 语， 然 后 实 现 序 列 协 议。</div>
<div class='sectionHeading'>10.3　协议和鸭子类型</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8420</div><div class='noteText'>在 Python 中 创 建 功 能 完 善 的 序 列 类 型 无 需 使 用 继 承， 只 需 实 现 符 合 序 列 协 议 的 方 法。 不 过， 这 里 说 的 协 议 是 什 么 呢？</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8421</div><div class='noteText'>在 面 向 对 象 编 程 中， 协 议 是 非 正 式 的 接 口， 只 在 文 档 中 定 义， 在 代 码 中 不 定 义。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8422</div><div class='noteText'>Python 的 序 列 协 议 只 需 要 __len__ 和 __getitem__ 两 个 方 法。 任 何 类（ 如 Spam）， 只 要 使 用 标 准 的 签 名 和 语 义 实 现 了 这 两 个 方 法， 就 能 用 在 任 何 期 待 序 列 的 地 方。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8441</div><div class='noteText'>协 议 是 非 正 式 的， 没 有 强 制 力， 因 此 如 果 你 知 道 类 的 具 体 使 用 场 景， 通 常 只 需 要 实 现 一 个 协 议 的 部 分。</div>
<div class='sectionHeading'>10.4　Vector类第2版：可切片的序列</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8461</div><div class='noteText'>切 片 得 到 的 是 列 表。 对 Vector 来 说， 如 果 切 片 生 成 普 通 的 数 组， 将 会 缺 失 大 量 功 能。</div>
<div class='sectionHeading'>10.4.1　切片原理</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8506</div><div class='noteText'>indices 方 法 开 放 了 内 置 序 列 实 现 的 棘 手 逻 辑， 用 于 优 雅 地 处 理 缺 失 索 引 和 负 数 索 引， 以 及 长 度 超 过 目 标 序 列 的 切 片。</div>
<div class='sectionHeading'>10.4.2　能处理切片的__getitem__方法</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8558</div><div class='noteText'>大 量 使 用 isinstance 可 能 表 明 面 向 对 象 设 计 得 不 好， 不 过 在 __getitem__ 方 法 中 使 用 它 处 理 切 片 是 合 理 的。</div>
<div class='sectionHeading'>10.5　Vector类第3版：动态存取属性</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8645</div><div class='noteText'>是 __getattr__ 的 运 作 方 式 导 致 的： 仅 当 对 象 没 有 指 定 名 称 的 属 性 时， Python 才 会 调 用 那 个 方 法， 这 是 一 种 后 备 机 制。 可 是， 像 v.x = 10 这 样 赋 值 之 后， v 对 象 有 x 属 性 了， 因 此 使 用 v.x 获 取 x 属 性 的 值 时 不 会 调 用 __getattr__ 方 法 了， 解 释 器 直 接 返 回 绑 定 到 v.x 上 的 值， 即 10。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8653</div><div class='noteText'>面，__getattr__ 方 法 的 实 现 没 有 考 虑 到 self._components 之 外 的 实 例 属 性， 而 是 从 这 个 属 性 中 获 取 shortcut_names 中 所 列 的“ 虚 拟 属 性”。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8696</div><div class='noteText'>们 没 有 禁 止 为 全 部 属 性 赋 值， 只 是 禁 止 为 单 个 小 写 字 母 属 性 赋 值， 以 防 与 只 读 属 性 x、 y、 z 和 t 混 淆。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8703</div><div class='noteText'>不 建 议 只 为 了 避 免 创 建 实 例 属 性 而 使 用 __slots__ 属 性。__slots__ 属 性 只 应 该 用 于 节 省 内 存， 而 且 仅 当 内 存 严 重 不 足 时 才 应 该 这 么 做。</div>
<div class='sectionHeading'>10.6　Vector类第4版：散列和快速等值测试</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8715</div><div class='noteText'>我 们 要 再 次 实 现 __hash__ 方 法。 加 上 现 有 的 __eq__ 方 法， 这 会 把 Vector 实 例 变 成 可 散 列 的 对 象。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8720</div><div class='noteText'>这 一 次， 我 们 要 使 用 ^（ 异 或） 运 算 符 依 次 计 算 各 个 分 量 的 散 列 值， 像 这 样： v[ 0] ^ v[ 1] ^ v[ 2]...。 这 正 是 functools.reduce 函 数 的 作 用。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8778</div><div class='noteText'>hashes = (hash( x) for x in self._components) # ➍ return functools.reduce( operator.xor, hashes, 0)</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8802</div><div class='noteText'>__hash__ 方 法 是 一 种 映 射 归 约 计 算（</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8813</div><div class='noteText'>Python 3 中， map 函 数 是 惰 性 的， 它 会 创 建 一 个 生 成 器， 按 需 产 出 结 果， 因 此 能 节 省 内 存—— 这 与 示 例 10-12 中 使 用 生 成 器 表 达 式 定 义 __hash__ 方 法 的 原 理 一 样。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8816</div><div class='noteText'>既 然 讲 到 了 归 约 函 数， 那 就 把 前 面 草 草 实 现 的 __eq__ 方 法 修 改 一 下， 减 少 处 理 时 间 和 内 存 用 量—— 至 少 对 大 型 向 量 来 说 是 这 样。 如 示 例 9-2 所 示，__eq__ 方 法 的 实 现 可 以 非 常 简 洁：</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8842</div><div class='noteText'>zip 函 数 生 成 一 个 由 元 组 构 成 的 生 成 器， 元 组 中 的 元 素 来 自 参 数 传 入 的 各 个 可 迭 代 对 象。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8868</div><div class='noteText'>出 色 的 zip 函 数</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 8870</div><div class='noteText'>其 中 一 个 是 内 置 的 zip 函 数。 使 用 zip 函 数 能 轻 松 地 并 行 迭 代 两 个 或 更 多 可 迭 代 对 象， 它 返 回 的 元 组 可 以 拆 包 成 变 量， 分 别 对 应 各 个 并 行 输 入 中 的 一 个 元 素。</div>
<div class='sectionHeading'>第 11 章　接口：从协议到抽象基类</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9192</div><div class='noteText'>抽 象 类 表 示 接 口。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9198</div><div class='noteText'>新 知 识 是 抽 象 基 类 的 严 格 规 定 和 类 型 检 查。 Python 语 言 诞 生 15 年 后， Python 2.6 才 引 入 抽 象 基 类。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9202</div><div class='noteText'>本 章 说 明 抽 象 基 类 的 常 见 用 途： 实 现 接 口 时 作 为 超 类 使 用。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9203</div><div class='noteText'>说 明 抽 象 基 类 如 何 检 查 具 体 子 类 是 否 符 合 接 口 定 义，</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9203</div><div class='noteText'>如 何 使 用 注 册 机 制 声 明 一 个 类 实 现 了 某 个 接 口， 而 不 进 行 子 类 化 操 作。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9204</div><div class='noteText'>如 何 让 抽 象 基 类 自 动“ 识 别” 任 何 符 合 接 口 的 类—— 不 进 行 子 类 化 或 注 册。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9207</div><div class='noteText'>抽 象 基 类 与 描 述 符 和 元 类 一 样， 是 用 于 构 建 框 架 的 工 具。</div>
<div class='sectionHeading'>11.1　Python文化中的接口和协议</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9214</div><div class='noteText'>类 实 现 或 继 承 的 公 开 属 性（ 方 法 或 数 据 属 性）， 包 括 特 殊 方 法， 如 __getitem__ 或 __add__。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9216</div><div class='noteText'>受 保 护 的 属 性 和 私 有 属 性 不 在 接 口 中： 即 便“ 受 保 护 的” 属 性 也 只 是 采 用 命 名 约 定 实 现 的（ 单 个 前 导 下 划 线）；</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9217</div><div class='noteText'>私 有 属 性 可 以 轻 松 地 访 问（ 参 见 9.7 节）， 原 因 也 是 如 此。 不 要 违 背 这 些 约 定。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9219</div><div class='noteText'>不 要 觉 得 把 公 开 数 据 属 性 放 入 对 象 的 接 口 中 不 妥， 因 为 如 果 需 要， 总 能 实 现 读 值 方 法 和 设 值 方 法， 把 数 据 属 性 变 成 特 性， 使 用 obj.attr 句 法 的 客 户 代 码 不 会 受 到 影 响。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9245</div><div class='noteText'>对 象 公 开 方 法 的 子 集， 让 对 象 在 系 统 中 扮 演 特 定 的 角 色。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9248</div><div class='noteText'>协 议 是 接 口， 但 不 是 正 式 的（ 只 由 文 档 和 约 定 定 义）， 因 此 协 议 不 能 像 正 式 接 口 那 样 施 加 限 制（ 本 章 后 面 会 说 明 抽 象 基 类 对 接 口 一 致 性 的 强 制）。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9261</div><div class='noteText'>序 列 协 议 是 Python 最 基 础 的 协 议 之 一。 即 便 对 象 只 实 现 了 那 个 协 议 最 基 本 的 一 部 分， 解 释 器 也 会 负 责 任 地 处 理，</div>
<div class='sectionHeading'>11.2　Python喜欢序列</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9286</div><div class='noteText'>综 上， 鉴 于 序 列 协 议 的 重 要 性， 如 果 没 有 __iter__ 和 __contains__ 方 法， Python 会 调 用 __getitem__ 方 法， 设 法 让 迭 代 和 in 运 算 符 可 用。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9303</div><div class='noteText'>象。 Python 中 的 迭 代 是 鸭 子 类 型 的 一 种 极 端 形 式： 为 了 迭 代 对 象， 解 释 器 会 尝 试 调 用 两 个 不 同 的 方 法。</div>
<div class='sectionHeading'>11.3　使用猴子补丁在运行时实现协议</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9329</div><div class='noteText'>置， 而 FrenchDeck 只 实 现 了 不 可 变 的 序 列 协 议。 可 变 的 序 列 还 必 须 提 供 __setitem__ 方 法。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9352</div><div class='noteText'>每 个 Python 方 法 说 到 底 都 是 普 通 函 数，</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9353</div><div class='noteText'>名 为 self 只 是 一 种 约 定。 在 控 制 台 会 话 中 使 用 那 几 个 参 数 没 问 题， 不 过 在 Python 源 码 文 件 中 最 好 按 照 文 档 那 样 使 用 self、 key 和 value。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9362</div><div class='noteText'>这 种 技 术 叫 猴 子 补 丁： 在 运 行 时 修 改 类 或 模 块， 而 不 改 动 源 码。 猴 子 补 丁 很 强 大， 但 是 打 补 丁 的 代 码 与 要 打 补 丁 的 程 序 耦 合 十 分 紧 密， 而 且 往 往 要 处 理 隐 藏 和 没 有 文 档 的 部 分。</div>
<div class='sectionHeading'>11.4　Alex Martelli的水禽</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9384</div><div class='noteText'>属 和 种（ 包 括 但 不 限 于 水 禽 所 属 的 鸭 科） 基 本 上 是 根 据 表 型 系 统 学（ phenetics） 分 类 的。 表 征 学 关 注 的 是 形 态 和 举 止 的 相 似 性…… 主 要 是 表 型 系 统 学 特 征。 因 此 使 用“ 鸭 子 类 型” 比 喻 是 贴 切 的。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9397</div><div class='noteText'>生 物（ 和 其 他 学 科） 遇 到 的 这 个 问 题， 迫 切 需 要（ 从 很 多 方 面 来 说， 是 催 生） 表 征 学 之 外 的 分 类 方 式 解 决， 即 支 序 系 统 学（ cladistics）。 这 种 分 类 学 主 要 根 据 从 共 同 祖 先 那 里 继 承 的 特 征 分 类， 而 不 是 单 独 进 化 的 特 征。（</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9417</div><div class='noteText'>Python 的 抽 象 基 类 还 有 一 个 重 要 的 实 用 优 势： 可 以 使 用 register 类 方 法 在 终 端 用 户 的 代 码 中 把 某 个 类“ 声 明” 为 一 个 抽 象 基 类 的“ 虚 拟” 子 类（ 为 此， 被 注 册 的 类 必 须 满 足 抽 象 基 类 对 方 法 名 称 和 签 名 的 要 求， 最 重 要 的 是 要 满 足 底 层 语 义 契 约； 但 是， 开 发 那 个 类 时 不 用 了 解 抽 象 基 类， 更 不 用 继 承 抽 象 基 类）。 这 大 大 地 打 破 了 严 格 的 强 耦 合， 与 面 向 对 象 编 程 人 员 掌 握 的 知 识 有 很 大 出 入， 因 此 使 用 继 承 时 要 小 心。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9422</div><div class='noteText'>为 了 让 抽 象 基 类 识 别 子 类， 甚 至 不 用 注 册。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9422</div><div class='noteText'>抽 象 基 类 的 本 质 就 是 几 个 特 殊 方 法。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9431</div><div class='noteText'>如 果 实 现 的 类 体 现 了 numbers、 collections.abc 或 其 他 框 架 中 抽 象 基 类 的 概 念， 要 么 继 承 相 应 的 抽 象 基 类（ 必 要 时）， 要 么 把 类 注 册 到 相 应 的 抽 象 基 类 中。 开 始 开 发 程 序 时， 不 要 使 用 提 供 注 册 功 能 的 库 或 框 架， 要 自 己 动 手 注 册； 如 果 必 须 检 查 参 数 的 类 型（ 这 是 最 常 见 的），</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9438</div><div class='noteText'>不 要 在 生 产 代 码 中 定 义 抽 象 基 类（ 或 元 类）……</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9441</div><div class='noteText'>你 还 可 以 自 己 定 义 抽 象 基 类， 但 是 我 不 建 议 高 级 Python 程 序 员 之 外 的 人 这 么 做； 同 样， 我 也 不 建 议 你 自 己 定 义 元 类……</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9443</div><div class='noteText'>如 此“ 深 层 次 的 元 编 程”， 如 果 可 以 这 么 讲 的 话， 适 合 框 架 的 作 者 使 用， 这 样 便 于 众 多 不 同 的 开 发 团 队 独 立 扩 展 框 架…… 真 正 需 要 这 么 做 的“ 高 级 Python 程 序 员” 不 超 过 1%。——</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9447</div><div class='noteText'>使 用 isinstance 和 issubclass 测 试 抽 象 基 类 更 为 人 接 受。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9450</div><div class='noteText'>即 便 是 抽 象 基 类， 也 不 能 滥 用 isinstance 检 查， 用 得 多 了 可 能 导 致 代 码 异 味， 即 表 明 面 向 对 象 设 计 得 不 好。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9454</div><div class='noteText'>此 时 应 该 使 用 多 态， 即 采 用 一 定 的 方 式 定 义 类， 让 解 释 器 把 调 用 分 派 给 正 确 的 方 法， 而 不 使 用 if/ elif/ elif 块 硬 编 码 分 派 逻 辑。</div>
<div class='sectionHeading'>11.5　定义抽象基类的子类</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9525</div><div class='noteText'>导 入 时（ 加 载 并 编 译 frenchdeck2. py 模 块 时）， Python 不 会 检 查 抽 象 方 法 的 实 现， 在 运 行 时 实 例 化 FrenchDeck2 类 时 才 会 真 正 检 查。 因 此， 如 果 没 有 正 确 实 现 某 个 抽 象 方 法， Python 会 抛 出 TypeError 异 常， 并 把 错 误 消 息 设 为&quot; Can't instantiate abstract class FrenchDeck2 with abstract methods</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9551</div><div class='noteText'>要 想 实 现 子 类， 我 们 可 以 覆 盖 从 抽 象 基 类 中 继 承 的 方 法， 以 更 高 效 的 方 式 重 新 实 现。</div>
<div class='sectionHeading'>11.6.1　collections.abc模块中的抽象基类</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9570</div><div class='noteText'>abc.ABC 类。 每 个 抽 象 基 类 都 依 赖 这 个 类， 但 是 不 用 导 入 它， 除 非 定 义 新 抽 象 基 类。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9610</div><div class='noteText'>这 两 个 抽 象 基 类 的 主 要 作 用 是 为 内 置 函 数 isinstance 提 供 支 持， 以 一 种 安 全 的 方 式 判 断 对 象 能 不 能 调 用 或 散 列。 7</div>
<div class='sectionHeading'>11.7　定义并使用一个抽象基类</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9700</div><div class='noteText'>抽 象 基 类 中 的 具 体 方 法 只 能 依 赖 抽 象 基 类 定 义 的 接 口（ 即 只 能 使 用 抽 象 基 类 中 的 其 他 具 体 方 法、 抽 象 方 法 或 特 性）。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9707</div><div class='noteText'>其 实， 抽 象 方 法 可 以 有 实 现 代 码。 即 便 实 现 了， 子 类 也 必 须 覆 盖 抽 象 方 法， 但 是 在 子 类 中 可 以 使 用 super() 函 数 调 用 抽 象 方 法， 为 它 添 加 功 能， 而 不 是 从 头 开 始 实 现。@</div>
<div class='sectionHeading'>11.7.1　抽象基类句法详解</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9774</div><div class='noteText'>因 此 如 果 你 使 用 的 是 旧 版 Python， 那 么 无 法 继 承 现 有 的 抽 象 基 类。 此 时， 必 须 在 class 语 句 中 使 用 metaclass = 关 键 字， 把 值 设 为 abc.ABCMeta（</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9784</div><div class='noteText'>__metaclass__ = abc.ABCMeta</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9791</div><div class='noteText'>后 三 个 装 饰 器 从 Python 3.3 起 废 弃 了， 因 为 装 饰 器 可 以 在 @abstractmethod 上 堆 叠， 那 三 个 就 显 得 多 余 了。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9797</div><div class='noteText'>在 函 数 上 堆 叠 装 饰 器 的 顺 序 通 常 很 重 要，@ abstractmethod 的 文 档 就 特 别 指 出：</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9798</div><div class='noteText'>与 其 他 方 法 描 述 符 一 起 使 用 时， abstractmethod() 应 该 放 在 最 里 层，……</div>
<div class='sectionHeading'>11.7.2　定义Tombola抽象基类的子类</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9846</div><div class='noteText'>这 里 想 表 达 的 观 点 是： 我 们 可 以 偷 懒， 直 接 从 抽 象 基 类 中 继 承 不 是 那 么 理 想 的 具 体 方 法。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9848</div><div class='noteText'>不 过 只 要 Tombola 的 子 类 正 确 实 现 pick 和 load 方 法， 就 能 提 供 正 确 的 结 果。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9890</div><div class='noteText'>接 下 来 要 讲 白 鹅 类 型 的 重 要 动 态 特 性 了： 使 用 register 方 法 声 明 虚 拟 子 类。</div>
<div class='sectionHeading'>11.7.3　Tombola的虚拟子类</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9893</div><div class='noteText'>白 鹅 类 型 的 一 个 基 本 特 性（ 也 是 值 得 用 水 禽 来 命 名 的 原 因）： 即 便 不 继 承， 也 有 办 法 把 一 个 类 注 册 为 抽 象 基 类 的 虚 拟 子 类。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9899</div><div class='noteText'>但 是 注 册 的 类 不 会 从 抽 象 基 类 中 继 承 任 何 方 法 或 属 性。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9900</div><div class='noteText'>虚 拟 子 类 不 会 继 承 注 册 的 抽 象 基 类， 而 且 任 何 时 候 都 不 会 检 查 它 是 否 符 合 抽 象 基 类 的 接 口， 即 便 在 实 例 化 时 也 不 会 检 查。 为 了 避 免 运 行 时 错 误， 虚 拟 子 类 要 实 现 所 需 的 全 部 方 法。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9903</div><div class='noteText'>也 可 以 作 为 装 饰 器 使 用。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9942</div><div class='noteText'>如 果 是 Python 3.3 或 之 前 的 版 本， 不 能 把 .register 当 作 类 装 饰 器 使 用， 必 须 使 用 标 准 的 调 用 句 法。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9950</div><div class='noteText'>而， 类 的 继 承 关 系 在 一 个 特 殊 的 类 属 性 中 指 定—— __mro__， 即 方 法 解 析 顺 序（ Method Resolution Order）。 这 个 属 性 的 作 用 很 简 单， 按 顺 序 列 出 类 及 其 超 类， Python 会 按 照 这 个 顺 序 搜 索 方 法。</div>
<div class='sectionHeading'>11.8　Tombola子类的测试方法</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9968</div><div class='noteText'>这 个 方 法 返 回 类 的 直 接 子 类 列 表， 不 含 虚 拟 子 类。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 9970</div><div class='noteText'>只 有 抽 象 基 类 有 这 个 数 据 属 性， 其 值 是 一 个 WeakSet 对 象， 即 抽 象 类 注 册 的 虚 拟 子 类 的 弱 引 用。</div>
<div class='sectionHeading'>11.9　Python使用register的方式</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10036</div><div class='noteText'>了， 但 更 常 见 的 做 法 还 是 把 它 当 作 函 数 使 用， 用 于 注 册 其 他 地 方 定 义 的 类。</div>
<div class='sectionHeading'>11.10　鹅的行为有可能像鸭子</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10080</div><div class='noteText'>__subclasshook__ 在 白 鹅 类 型 中 添 加 了 一 些 鸭 子 类 型 的 踪 迹。 我 们 可 以 使 用 抽 象 基 类 定 义 正 式 接 口， 可 以 始 终 使 用 isinstance 检 查， 也 可 以 完 全 使 用 不 相 关 的 类， 只 要 实 现 特 定 的 方 法 即 可（ 或 者 做 些 事 情 让 __subclasshook__ 信 服）。 当 然， 只 有 提 供 __subclasshook__ 方 法 的 抽 象 基 类 才 能 这 么 做。</div>
<div class='sectionHeading'>11.11　本章小结</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10119</div><div class='noteText'>Alex Martelli 介 绍 了“ 白 鹅 类 型” 这 个 术 语， 18 以 此 描 述 一 种 新 的 Python 编 程 风 格。 借 助“ 白 鹅 类 型”， 可 以 使 用 抽 象 基 类 明 确 声 明 接 口， 而 且 类 可 以 子 类 化 抽 象 基 类 或 使 用 抽 象 基 类 注 册（ 无 需 在 继 承 关 系 中 确 立 静 态 的 强 链 接）， 宣 称 它 实 现 了 某 个 接 口。</div>
<div class='sectionHeading'>11.12　延伸阅读</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10197</div><div class='noteText'>Python 世 界 最 大 的 新 闻 应 该 是 Guido van Rossum 同 意 实 现 可 选 的 静 态 类 型 检 查， 这 与 检 查 程 序 Mypy 的 做 法 类 似， 即 使 用 函 数 注 解 实 现。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10204</div><div class='noteText'>从 表 面 上 看， 这 与 Microsoft 对 TypeScript（ JavaScript 的 超 集） 采 取 的 方 式 类 似， 不 过 TypeScript 做 得 更 进 一 步： TypeScript 添 加 了 新 的 语 言 结 构（ 如 模 块、 类、 显 式 接 口， 等 等）， 允 许 声 明 变 量 类 型， 而 且 最 终 编 译 成 常 规 的 JavaScript。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10278</div><div class='noteText'>我 从 Cooper 的 书 中 学 到 的 最 宝 贵 的 知 识 是， 不 把 隐 喻 当 作 设 计 范 式， 而 代 之 以“ 习 惯 用 法 的 界 面”。</div>
<div class='sectionHeading'>第 12 章　继承的优缺点</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10286</div><div class='noteText'>推 出 继 承 的 初 衷 是 让 新 手 顺 利 使 用 只 有 专 家 才 能 设 计 出 来 的 框 架。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10297</div><div class='noteText'>这 两 个 项 目 是 GUI 工 具 包 Tkinter 和 Web 框 架 Django。</div>
<div class='sectionHeading'>12.1　子类化内置类型很麻烦</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10302</div><div class='noteText'>内 置 类 型（ 使 用 C 语 言 编 写） 不 会 调 用 用 户 定 义 的 类 覆 盖 的 特 殊 方 法。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10332</div><div class='noteText'>中，__missing__ 方 法（ 参 见 3.4.2 节） 却 能 按 预 期 方 式 工 作， 不 过 这 只 是 特 例。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10334</div><div class='noteText'>不 只 实 例 内 部 的 调 用 有 这 个 问 题（ self.get() 不 调 用 self.__getitem__()）， 内 置 类 型 的 方 法 调 用 的 其 他 类 的 方 法， 如 果 被 覆 盖 了， 也 不 会 被 调 用。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10358</div><div class='noteText'>不 要 子 类 化 内 置 类 型， 用 户 自 己 定 义 的 类 应 该 继 承 collections 模 块 中 的 类， 例 如 UserDict、 UserList 和 UserString， 这 些 类 做 了 特 殊 设 计， 因 此 易 于 扩 展。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10393</div><div class='noteText'>如 果 子 类 化 使 用 Python 编 写 的 类， 如 UserDict 或 MutableMapping， 就 不 会 受 此 影 响。</div>
<div class='sectionHeading'>12.2　多重继承和方法解析顺序</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10403</div><div class='noteText'>虚 线 箭 头 是 示 例 12-4 使 用 的 方 法 解 析 顺 序</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10430</div><div class='noteText'>Python 能 区 分 d.pong() 调 用 的 是 哪 个 方 法， 是 因 为 Python 会 按 照 特 定 的 顺 序 遍 历 继 承 图。 这 个 顺 序 叫 方 法 解 析 顺 序（ Method Resolution Order， MRO）。 类 都 有 一 个 名 为 __mro__ 的 属 性， 它 的 值 是 一 个 元 组， 按 照 方 法 解 析 顺 序 列 出 各 个 超 类， 从 当 前 类 一 直 向 上， 直 到 object 类。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10442</div><div class='noteText'>直 接 调 用 某 个 超 类 的 方 法—— 这 样 做 有 时 更 方 便。 例 如， D.ping 方 法 可 以 这 样 写：</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10448</div><div class='noteText'>A.ping( self)</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10449</div><div class='noteText'>直 接 在 类 上 调 用 实 例 方 法 时， 必 须 显 式 传 入 self 参 数， 因 为 这 样 访 问 的 是 未 绑 定 方 法（</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10492</div><div class='noteText'>方 法 解 析 顺 序 不 仅 考 虑 继 承 图， 还 考 虑 子 类 声 明 中 列 出 超 类 的 顺 序。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10520</div><div class='noteText'>方 法 解 析 顺 序 使 用 C3 算 法 计 算。 Michele Simionato 的 论 文“ The Python 2.3 Method Resolution Order” 对 Python 方 法 解 析 顺 序 使 用 的 C3 算 法 做 了 权 威 论 述。 如 果 对 方 法 解 析 顺 序 的 细 节 感 兴 趣， 可 以 阅 读 延 伸 阅 读 中 给 出 的 资 料。 不 用 过 分 担 心， C3 算 法 不 难 理 解， Simionato 写 道： …… 除 非 大 量 使 用 多 重 继 承， 或 者 继 承 关 系 不 同 寻 常， 否 则 不 用 了 解 C3 算 法， 因 此 也 不 用 阅 读 这 篇 论 文。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10534</div><div class='noteText'>使 用 虚 线 箭 头 表 示 Text.__mro__</div>
<div class='sectionHeading'>12.3　多重继承的真实应用</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10537</div><div class='noteText'>那 本 书 中 的 其 他 22 个 设 计 模 式 都 使 用 单 继 承， 因 此 多 重 继 承 显 然 不 是 灵 丹 妙 药）。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10538</div><div class='noteText'>在 Python 标 准 库 中， 最 常 使 用 多 重 继 承 的 是 collections.abc 包。</div>
<div class='sectionHeading'>12.4　处理多重继承</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10592</div><div class='noteText'>把 接 口 继 承 和 实 现 继 承 区 分 开</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10596</div><div class='noteText'>通 过 继 承 重 用 代 码 是 实 现 细 节， 通 常 可 以 换 用 组 合 和 委 托 模 式。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10596</div><div class='noteText'>而 接 口 继 承 则 是 框 架 的 支 柱。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10597</div><div class='noteText'>使 用 抽 象 基 类 显 式 表 示 接 口</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10598</div><div class='noteText'>现 代 的 Python 中， 如 果 类 的 作 用 是 定 义 接 口， 应 该 明 确 把 它 定 义 为 抽 象 基 类。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10601</div><div class='noteText'>通 过 混 入 重 用 代 码</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10602</div><div class='noteText'>系， 应 该 把 那 个 类 明 确 地 定 义 为 混 入 类（ mixin class）。 从 概 念 上 讲， 混 入 不 定 义 新 类 型， 只 是 打 包 方 法， 便 于 重 用。 混 入 类 绝 对 不 能 实 例 化， 而 且 具 体 类 不 能 只 继 承 混 入 类。 混 入 类 应 该 提 供 某 方 面 的 特 定 行 为， 只 实 现 少 量 关 系 非 常 紧 密 的 方 法。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10611</div><div class='noteText'>抽 象 基 类 可 以 作 为 混 入， 反 过 来 则 不 成 立</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10614</div><div class='noteText'>抽 象 基 类 有 个 局 限 是 混 入 没 有 的： 抽 象 基 类 中 实 现 的 具 体 方 法 只 能 与 抽 象 基 类 及 其 超 类 中 的 方 法 协 作。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10617</div><div class='noteText'>具 体 类 可 以 没 有， 或 最 多 只 有 一 个 具 体 超 类。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10618</div><div class='noteText'>具 体 类 的 超 类 中 除 了 这 一 个 具 体 超 类 之 外， 其 余 的 都 是 抽 象 基 类 或 混 入。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10625</div><div class='noteText'>如 果 抽 象 基 类 或 混 入 的 组 合 对 客 户 代 码 非 常 有 用， 那 就 提 供 一 个 类， 使 用 易 于 理 解 的 方 式 把 它 们 结 合 起 来。 Grady Booch 把 这 种 类 称 为 聚 合 类（</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10637</div><div class='noteText'>“优 先 使 用 对 象 组 合， 而 不 是 类 继 承”</div>
<div class='sectionHeading'>Tkinter好的、不好的和令人厌恶的方面</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10658</div><div class='noteText'>因 为 使 用 组 合 模 式 把 几 何 管 理 器 集 成 到 Widget 中 更 好，</div>
<div class='sectionHeading'>12.5　一个现代示例：Django通用视图中的混入</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10688</div><div class='noteText'>一 个 现 代 示 例： Django 通 用 视 图 中 的 混 入</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10698</div><div class='noteText'>Django 1.3 引 入 了 基 于 类 的 视 图， 而 且 还 通 过 基 类、 混 入 和 拿 来 即 用 的 具 体 类 提 供 了 一 些 通 用 视 图 类。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10729</div><div class='noteText'>你 会 发 现 Django 的 分 派 机 制 是 动 态 版 模 板 方 法 模 式。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10755</div><div class='noteText'>Django 基 于 类 的 视 图 API 是 多 重 继 承 更 好 的 示 例。 尤 其 是， Django 的 混 入 类 易 于 理 解： 各 个 混 入 的 目 的 明 确， 而 且 名 称 的 后 缀 都 是 ... Mixin。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10758</div><div class='noteText'>很 多 Django 程 序 员 依 然 选 择 编 写 单 块 视 图 函 数， 负 责 处 理 所 有 事 务， 而 不 尝 试 重 用 基 视 图 和 混 入。</div>
<div class='sectionHeading'>12.7　延伸阅读</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10806</div><div class='noteText'>我 读 过 Grady Booch 写 的《 面 向 对 象 分 析 与 设 计（ 第 3 版）》， 强 烈 推 荐 给 你， 这 是 面 向 对 象 思 维 的 通 用 入 门 书， 与 具 体 的 编 程 语 言 无 关。 很 少 有 书 能 这 样 不 带 偏 见 地 讨 论 多 重 继 承。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10837</div><div class='noteText'>Java 8 引 入 了 默 认 方 法，</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10838</div><div class='noteText'>别： Java 的 接 口 没 有 状 态。 Java 之 后， 使 用 最 广 泛 的 JVM 语 言 要 数 Scala 了， 而 它 实 现 了 性 状。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10840</div><div class='noteText'>性 状 是 目 前 的 趋 势。</div>
<div class='sectionHeading'>第 13 章　正确重载运算符</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10866</div><div class='noteText'>Python 如 何 处 理 中 缀 运 算 符 中 不 同 类 型 的 操 作 数</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10866</div><div class='noteText'>使 用 鸭 子 类 型 或 显 式 类 型 检 查 处 理 不 同 类 型 的 操 作 数</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10867</div><div class='noteText'>中 缀 运 算 符 如 何 表 明 自 己 无 法 处 理 操 作 数</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10868</div><div class='noteText'>众 多 比 较 运 算 符（ 如 = =、 &gt;、 &lt; =， 等 等） 的 特 殊 行 为</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10871</div><div class='noteText'>增 量 赋 值 运 算 符（ 如 + =） 的 默 认 处 理 方 式 和 重 载 方 式</div>
<div class='sectionHeading'>13.1　运算符重载基础</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10875</div><div class='noteText'>不 能 重 载 内 置 类 型 的 运 算 符</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10876</div><div class='noteText'>不 能 新 建 运 算 符， 只 能 重 载 现 有 的</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10877</div><div class='noteText'>某 些 运 算 符 不 能 重 载—— is、 and、 or 和 not（ 不 过 位 运 算 符 &amp;、 | 和 ~ 可 以）</div>
<div class='sectionHeading'>13.2　一元运算符</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10918</div><div class='noteText'>要 遵 守 运 算 符 的 一 个 基 本 规 则： 始 终 返 回 一 个 新 对 象。 也 就 是 说， 不 能 修 改 self， 要 创 建 并 返 回 合 适 类 型 的 新 实 例。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10920</div><div class='noteText'>对 - 和 + 来 说， 结 果 可 能 是 与 self 同 属 一 类 的 实 例。 多 数 时 候， + 最 好 返 回 self 的 副 本。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 10986</div><div class='noteText'>Counter 类 实 现 了 几 个 算 术 运 算 符， 例 如 中 缀 运 算 符 +， 作 用 是 把 两 个 Counter 实 例 的 计 数 器 加 在 一 起。 然 而， 从 实 用 角 度 出 发， Counter 相 加 时， 负 值 和 零 值 计 数 会 从 结 果 中 剔 除。 而 一 元 运 算 符 + 等 同 于 加 上 一 个 空 Counter， 因 此 它 产 生 一 个 新 的 Counter 且 仅 保 留 大 于 零 的 计 数 器。</div>
<div class='sectionHeading'>13.3　重载向量加法运算符+</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 11065</div><div class='noteText'>制。 对 表 达 式 a + b 来 说， 解 释 器 会 执 行 以 下 几 步 操 作（ 见 图 13-1）。 (1) 如 果 a 有 __add__ 方 法， 而 且 返 回 值 不 是 NotImplemented， 调 用 a.__add__( b)， 然 后 返 回 结 果。 (2) 如 果 a 没 有 __add__ 方 法， 或 者 调 用 __add__ 方 法 返 回 NotImplemented， 检 查 b 有 没 有 __radd__ 方 法， 如 果 有， 而 且 没 有 返 回 NotImplemented， 调 用 b.__radd__( a)， 然 后 返 回 结 果。 (3) 如 果 b 没 有 __radd__ 方 法， 或 者 调 用 __radd__ 方 法 返 回 NotImplemented， 抛 出 TypeError， 并 在 错 误 消 息 中 指 明 操 作 数 类 型 不 支 持。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 11103</div><div class='noteText'>而 NotImplementedError 是 一 种 异 常， 抽 象 类 中 的 占 位 方 法 把 它 抛 出（ raise）， 提 醒 子 类 必 须 覆 盖。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 11139</div><div class='noteText'>如 果 由 于 类 型 不 兼 容 而 导 致 运 算 符 特 殊 方 法 无 法 返 回 有 效 的 结 果， 那 么 应 该 返 回 NotImplemented， 而 不 是 抛 出 TypeError。 返 回 NotImplemented 时， 另 一 个 操 作 数 所 属 的 类 型 还 有 机 会 执 行 运 算， 即 Python 会 尝 试 调 用 反 向 方 法。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 11143</div><div class='noteText'>为 了 遵 守 鸭 子 类 型 精 神， 我 们 不 能 测 试 other 操 作 数 的 类 型， 或 者 它 的 元 素 的 类 型。 我 们 要 捕 获 异 常， 然 后 返 回 NotImplemented。 如 果 解 释 器 还 未 反 转 操 作 数， 那 么 它 将 尝 试 去 做。 如 果 反 向 方 法 返 回 NotImplemented， 那 么 Python 会 抛 出 TypeError， 并 返 回 一 个 标 准 的 错 误 消 息， 例 如“ unsupported operand type( s) for +: Vector and str”。</div>
<div class='sectionHeading'>13.4　重载标量乘法运算符*</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 11345</div><div class='noteText'>积）。@ 运 算 符 由 特 殊 方 法 __matmul__、__rmatmul__ 和 __imatmul__ 提 供 支 持， 名 称 取 自“ matrix multiplication”（ 矩 阵 乘 法）。 目 前， 标 准 库 还 没 用 到 这 些 方 法， 但 是 Python 3.5 的 解 释 器 能 识 别，</div>
<div class='sectionHeading'>第 14 章　可迭代的对象、迭代器和生成器</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 11867</div><div class='noteText'>生 成 器 和 协 程 看 似 相 同， 实 则 差 别 很 大， 不 能 混 淆</div>
<div class='sectionHeading'>14.6　Sentence类第5版：生成器表达式</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 12302</div><div class='noteText'>生 成 器 表 达 式 可 以 理 解 为 列 表 推 导 的 惰 性 版 本： 不 会 迫 切 地 构 建 列 表， 而 是 返 回 一 个 生 成 器， 按 需 惰 性 生 成 元 素。 也 就 是 说， 如 果 列 表 推 导 是 制 造 列 表 的 工 厂， 那 么 生 成 器 表 达 式 就 是 制 造 生 成 器 的 工 厂。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 12345</div><div class='noteText'>生 成 器 表 达 式 是 语 法 糖： 完 全 可 以 替 换 成 生 成 器 函 数， 不 过 有 时 使 用 生 成 器 表 达 式 更 便 利。</div>
<div class='sectionHeading'>14.7　何时使用生成器表达式</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 12355</div><div class='noteText'>生 成 器 函 数 灵 活 得 多， 可 以 使 用 多 个 语 句 实 现 复 杂 的 逻 辑， 也 可 以 作 为 协 程 使 用（</div>
<div class='sectionHeading'>使用itertools模块生成等差数列</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 12488</div><div class='noteText'>实 现 生 成 器 时 要 知 道 标 准 库 中 有 什 么 可 用， 否 则 很 可 能 会 重 新 发 明 轮 子。</div>
<div class='sectionHeading'>14.9　标准库中的生成器函数</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 12804</div><div class='noteText'>数， 内 置 的 reversed 函 数， 是 本 节 所 述 的 函 数 中 唯 一 一 个 不 接 受 可 迭 代 的 对 象， 而 只 接 受 序 列 为 参 数 的 函 数。</div>
<div class='sectionHeading'>14.10　Python 3.3中新出现的句法：yield from</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 12891</div><div class='noteText'>糖。 除 了 代 替 循 环 之 外， yield from 还 会 创 建 通 道， 把 内 层 生 成 器 直 接 与 外 层 生 成 器 的 客 户 端 联 系 起 来。 把 生 成 器 当 成 协 程 使 用 时， 这 个 通 道 特 别 重 要， 不 仅 能 为 客 户 端 代 码 生 成 值， 还 能 使 用 客 户 端 代 码 提 供 的 值。</div>
<div class='sectionHeading'>14.12　深入分析iter函数</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 12970</div><div class='noteText'>iter 函 数 还 有 一 个 鲜 为 人 知 的 用 法： 传 入 两 个 参 数， 使 用 常 规 的 函 数 或 任 何 可 调 用 的 对 象 创 建 迭 代 器。 这 样 使 用 时， 第 一 个 参 数 必 须 是 可 调 用 的 对 象， 用 于 不 断 调 用（ 没 有 参 数）， 产 出 各 个 值； 第 二 个 值 是 哨 符， 这 是 个 标 记 值， 当 可 调 用 的 对 象 返 回 这 个 值 时， 触 发 迭 代 器 抛 出 StopIteration 异 常， 而 不 产 出 哨 符。</div>
<div class='sectionHeading'>14.13　案例分析：在数据库转换工具中使用生成器</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13040</div><div class='noteText'>我 利 用 生 成 器 函 数 解 耦 了 读 逻 辑 和 写 逻 辑。 当 然， 解 耦 二 者 最 简 单 的 方 式 是， 把 所 有 记 录 读 进 内 存， 然 后 写 入 硬 盘。 可 是 这 样 并 不 可 行， 因 为 数 据 集 很 大。 而 使 用 生 成 器 的 话， 可 以 交 叉 读 写， 因 此 这 个 脚 本 可 以 处 理 任 意 大 小 的 文 件。</div>
<div class='sectionHeading'>14.14　把生成器当成协程</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13055</div><div class='noteText'>过，. send() 方 法 还 允 许 使 用 生 成 器 的 客 户 把 数 据 发 给 自 己， 即 不 管 传 给 .send() 方 法 什 么 参 数， 那 个 参 数 都 会 成 为 生 成 器 函 数 定 义 体 中 对 应 的 yield 表 达 式 的 值。 也 就 是 说，. send() 方 法 允 许 在 客 户 代 码 和 生 成 器 之 间 双 向 交 换 数 据。 而 .__next__() 方 法 只 允 许 客 户 从 生 成 器 中 获 取 数 据。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13061</div><div class='noteText'>这 是 一 项 重 要 的“ 改 进”， 甚 至 改 变 了 生 成 器 的 本 性： 像 这 样 使 用 的 话， 生 成 器 就 变 身 为 协 程。</div>
<div class='sectionHeading'>14.16　延伸阅读</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13145</div><div class='noteText'>而 Python 2.5 引 入 的 协 程（ 也 写 成 包 含 yield 关 键 字 的 函 数） 把 这 个 问 题 进 一 步 恶 化 了。 在 协 程 中， yield 碰 巧（ 通 常） 出 现 在 赋 值 语 句 的 右 手 边， 因 为 yield 用 于 接 收 客 户 传 给 .send() 方 法 的 参 数。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13150</div><div class='noteText'>尽 管 有 一 些 相 同 之 处， 但 是 生 成 器 和 协 程 基 本 上 是 两 个 不 同 的 概 念。 19</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13152</div><div class='noteText'>协 程 经 常 会 用 到 特 殊 的 装 饰 器， 这 样 就 能 与 其 他 的 函 数 区 分 开。 可</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13152</div><div class='noteText'>生 成 器 函 数 不 常 使 用 装 饰 器， 因 此 我 们 不 得 不 扫 描 函 数 的 定 义 体， 看 有 没 有 yield 关 键 字， 以 此 判 断 它 究 竟 是 普 通 的 函 数， 还 是 完 全 不 同 的 洪 水 猛 兽。</div>
<div class='sectionHeading'>第 15 章　上下文管理器和 else 块</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13226</div><div class='noteText'>最 终， 上 下 文 管 理 器 可 能 几 乎 与 子 程 序（ subroutine） 本 身 一 样 重 要。 目 前， 我 们 只 了 解 了 上 下 文 管 理 器 的 皮 毛……</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13237</div><div class='noteText'>with 语 句 和 上 下 文 管 理 器</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13241</div><div class='noteText'>with 语 句 会 设 置 一 个 临 时 的 上 下 文， 交 给 上 下 文 管 理 器 对 象 控 制， 并 且 负 责 清 理 上 下 文。 这 么 做 能 避 免 错 误 并 减 少 样 板 代 码， 因 此 API 更 安 全， 而 且 更 易 于 使 用。 除 了 自 动 关 闭 文 件 之 外， with 块 还 有 很 多 用 途。</div>
<div class='sectionHeading'>15.1　先做这个，再做那个：if语句之外的else块</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13274</div><div class='noteText'>在 所 有 情 况 下， 如 果 异 常 或 者 return、 break 或 continue 语 句 导 致 控 制 权 跳 到 了 复 合 语 句 的 主 块 之 外， else 子 句 也 会 被 跳 过。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13315</div><div class='noteText'>取 得 原 谅 比 获 得 许 可 容 易（</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13320</div><div class='noteText'>三 思 而 后 行（</div>
<div class='sectionHeading'>15.2　上下文管理器和with块</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13363</div><div class='noteText'>点： 执 行 with 后 面 的 表 达 式 得 到 的 结 果 是 上 下 文 管 理 器 对 象， 不 过， 把 值 绑 定 到 目 标 变 量 上（ as 子 句） 是 在 上 下 文 管 理 器 对 象 上 调 用 __enter__ 方 法 的 结 果。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13370</div><div class='noteText'>不 过，__enter__ 方 法 除 了 返 回 上 下 文 管 理 器 之 外， 还 可 能 返 回 其 他 对 象。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13371</div><div class='noteText'>不 管 控 制 流 程 以 哪 种 方 式 退 出 with 块， 都 会 在 上 下 文 管 理 器 对 象 上 调 用 __exit__ 方 法， 而 不 是 在 __enter__ 方 法 返 回 的 对 象 上 调 用。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13435</div><div class='noteText'>解 释 器 调 用 __enter__ 方 法 时， 除 了 隐 式 的 self 之 外， 不 会 传 入 任 何 参 数。 传 给 __exit__ 方 法 的 三 个 参 数 列 举 如 下。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13477</div><div class='noteText'>管 理 事 务，</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13480</div><div class='noteText'>于 维 护 锁、 条 件 和 信 号，</div>
<div class='sectionHeading'>15.3　contextlib模块中的实用工具</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13502</div><div class='noteText'>这 个 装 饰 器 把 简 单 的 生 成 器 函 数 变 成 上 下 文 管 理 器， 这 样 就 不 用 创 建 类 去 实 现 管 理 器 协 议 了。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13512</div><div class='noteText'>使 用 最 广 泛 的 是 @contextmanager 装 饰 器， 因 此 要 格 外 留 心。 这 个 装 饰 器 也 有 迷 惑 人 的 一 面， 因 为 它 与 迭 代 无 关， 却 要 使 用 yield 语 句。 由 此 可 以 引 出 协 程， 这 是 下 一 章 的 主 题。</div>
<div class='sectionHeading'>15.4　使用@contextmanager</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13517</div><div class='noteText'>@contextmanager 装 饰 器 能 减 少 创 建 上 下 文 管 理 器 的 样 板 代 码 量， 因 为 不 用 编 写 一 个 完 整 的 类， 定 义 __enter__ 和 __exit__ 方 法， 而 只 需 实 现 有 一 个 yield 语 句 的 生 成 器， 生 成 想 让 __enter__ 方 法 返 回 的 值。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13521</div><div class='noteText'>在 使 用 @contextmanager 装 饰 的 生 成 器 中， yield 语 句 的 作 用 是 把 函 数 的 定 义 体 分 成 两 部 分： yield 语 句 前 面 的 所 有 代 码 在 with 块 开 始 时（ 即 解 释 器 调 用 __enter__ 方 法 时） 执 行， yield 语 句 后 面 的 代 码 在 with 块 结 束 时（ 即 调 用 __exit__ 方 法 时） 执 行。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13603</div><div class='noteText'>使 用 @contextmanager 装 饰 器 时， 默 认 的 行 为 是 相 反 的： 装 饰 器 提 供 的 __exit__ 方 法 假 定 发 给 生 成 器 的 所 有 异 常 都 得 到 处 理 了， 因 此 应 该 压 制 异 常。 6 如 果 不 想 让 @contextmanager 压 制 异 常， 必 须 在 被 装 饰 的 函 数 中 显 式 重 新 抛 出 异 常。 7</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13612</div><div class='noteText'>使 用 @contextmanager 装 饰 器 时， 要 把 yield 语 句 放</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13614</div><div class='noteText'>在 try/ finally 语 句 中（ 或 者 放 在 with 语 句 中）， 这 是 无 法 避 免 的， 因 为 我 们 永 远 不 知 道 上 下 文 管 理 器 的 用 户 会 在 with 块 中 做 什 么。</div>
<div class='sectionHeading'>第 16 章　协程</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13724</div><div class='noteText'>可 是， 在 协 程 中， yield 通 常 出 现 在 表 达 式 的 右 边（ 例 如， datum = yield）， 可 以 产 出 值， 也 可 以 不 产 出—— 如 果 yield 关 键 字 后 面 没 有 表 达 式， 那 么 生 成 器 产 出 None。 协 程 可 能 会 从 调 用 方 接 收 数 据， 不 过 调 用 方 把 数 据 提 供 给 协 程 使 用 的 是 .send( datum) 方 法， 而 不 是 next(...) 函 数。 通 常， 调 用 方 会 把 值 推 送 给 协 程。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13731</div><div class='noteText'>yield 关 键 字 甚 至 还 可 以 不 接 收 或 传 出 数 据。 不 管 数 据 如 何 流 动， yield 都 是 一 种 流 程 控 制 工 具， 使 用 它 可 以 实 现 协 作 式 多 任 务： 协 程 可 以 把 控 制 器 让 步 给 中 心 调 度 程 序， 从 而 激 活 其 他 的 协 程。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13734</div><div class='noteText'>从 根 本 上 把 yield 视 作 控 制 流 程 的 方 式， 这 样 就 好 理 解 协 程 了。</div>
<div class='sectionHeading'>16.1　生成器如何进化成协程</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13746</div><div class='noteText'>自 此 之 后， yield 关 键 字 可 以 在 表 达 式 中 使 用， 而 且 生 成 器 API 中 增 加 了 .send( value) 方 法。 生 成 器 的 调 用 方 可 以 使 用 .send(...) 方 法 发 送 数 据， 发 送 的 数 据 会 成 为 生 成 器 函 数 中 yield 表 达 式 的 值。 因 此， 生 成 器 可 以 作 为 协 程 使 用。 协 程 是 指 一 个 过 程， 这 个 过 程 与 调 用 方 协 作， 产 出 由 调 用 方 提 供 的 值。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13751</div><div class='noteText'>除 了 .send(...) 方 法， PEP 342 还 添 加 了 .throw(...) 和 .close() 方 法： 前 者 的 作 用 是 让 调 用 方 抛 出 异 常， 在 生 成 器 中 处 理； 后 者 的 作 用 是 终 止 生 成 器。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13755</div><div class='noteText'>协 程 最 近 的 演 进 来 自 Python 3.3（ 2012 年） 实 现 的“ PEP 380— Syntax for Delegating to a Subgenerator”。 PEP 380 对 生 成 器 函 数 的 句 法 做 了 两 处 改 动， 以 便 更 好 地 作 为 协 程 使 用。</div>
<div class='sectionHeading'>16.2　用作协程的生成器的基本行为</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13777</div><div class='noteText'>首 先 要 调 用 next(...) 函 数， 因 为 生 成 器 还 没 启 动， 没 在 yield 语 句 处 暂 停， 所 以 一 开 始 无 法 发 送 数 据。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13779</div><div class='noteText'>调 用 这 个 方 法 后， 协 程 定 义 体 中 的 yield 表 达 式 会 计 算 出 42； 现 在， 协 程 会 恢 复， 一 直 运 行 到 下 一 个 yield 表 达 式， 或 者 终 止。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13796</div><div class='noteText'>因 为 send 方 法 的 参 数 会 成 为 暂 停 的 yield 表 达 式 的 值， 所 以， 仅 当 协 程 处 于 暂 停 状 态 时 才 能 调 用 send 方 法， 例 如 my_coro.send( 42)。 不 过， 如 果 协 程 还 没 激 活（ 即， 状 态 是 'GEN_CREATED'）， 情 况 就 不 同 了。 因 此， 始 终 要 调 用 next( my_coro) 激 活 协 程—— 也 可 以 调 用 my_coro.send( None)， 效 果 一 样。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13843</div><div class='noteText'>关 键 的 一 点 是， 协 程 在 yield 关 键 字 所 在 的 位 置 暂 停 执 行。 前 面 说 过， 在 赋 值 语 句 中， = 右 边 的 代 码 在 赋 值 之 前 执 行。 因 此， 对 于 b = yield a 这 行 代 码 来 说， 等 到 客 户 端 代 码 再 激 活 协 程 时 才 会 设 定 b 的 值。 这 种 行 为 要 花 点 时 间 才 能 习 惯， 不 过 一 定 要 理 解， 这 样 才 能 弄 懂 异 步 编 程 中 yield 的 作 用（ 后 文 探 讨）。</div>
<div class='sectionHeading'>16.4　预激协程的装饰器</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13950</div><div class='noteText'>很 多 框 架 都 提 供 了 处 理 协 程 的 特 殊 装 饰 器， 不 过 不 是 所 有 装 饰 器 都 用 于 预 激 协 程， 有 些 会 提 供 其 他 服 务， 例 如 勾 入 事 件 循 环。 比 如 说， 异 步 网 络 库 Tornado 提 供 了 tornado.gen 装 饰 器。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13953</div><div class='noteText'>使 用 yield from 句 法（ 参 见 16.7 节） 调 用 协 程 时， 会 自 动 预 激， 因 此 与 示 例 16-5 中 的 @coroutine 等 装 饰 器 不 兼 容。 Python 3.4 标 准 库 里 的 asyncio.coroutine 装 饰 器（ 第 18 章 介 绍） 不 会 预 激 协 程， 因 此 能 兼 容 yield from 句 法。</div>
<div class='sectionHeading'>16.5　终止协程和异常处理</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13975</div><div class='noteText'>暗 示 了 终 止 协 程 的 一 种 方 式： 发 送 某 个 哨 符 值， 让 协 程 退 出。 内 置 的 None 和 Ellipsis 等 常 量 经 常 用 作 哨 符 值。 Ellipsis 的 优 点 是， 数 据 流 中 不 太 常 有 这 个 值。 我 还 见 过 有 人 把 StopIteration 类（ 类 本 身， 而 不 是 实 例， 也 不 抛 出） 作 为 哨 符 值； 也 就 是 说， 是 像 这 样 使 用 的： my_coro.send( StopIteration)。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13986</div><div class='noteText'>如 果 生 成 器 处 理 了 抛 出 的 异 常， 代 码 会 向 前 执 行 到 下 一 个 yield 表 达 式， 而 产 出 的 值 会 成 为 调 用 generator.throw 方 法 得 到 的 返 回 值。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13988</div><div class='noteText'>如 果 生 成 器 没 有 处 理 抛 出 的 异 常， 异 常 会 向 上 冒 泡， 传 到 调 用 方 的 上 下 文 中。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13991</div><div class='noteText'>生 成 器 在 暂 停 的 yield 表 达 式 处 抛 出 GeneratorExit 异 常。 如 果 生 成 器 没 有 处 理 这 个 异 常， 或 者 抛 出 了 StopIteration 异 常（ 通 常 是 指 运 行 到 结 尾）， 调 用 方 不 会 报 错。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 13994</div><div class='noteText'>如 果 收 到 GeneratorExit 异 常， 生 成 器 一 定 不 能 产 出 值， 否 则 解 释 器 会 抛 出 RuntimeError 异 常。 生 成 器 抛 出 的 其 他 异 常 会 向 上 冒 泡， 传 给 调 用 方。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14039</div><div class='noteText'>如 果 不 管 协 程 如 何 结 束 都 想 做 些 清 理 工 作， 要 把 协 程 定 义 体 中 相 关 的 代 码 放 入 try/ finally 块 中，</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14050</div><div class='noteText'>Python 3.3 引 入 yield from 结 构 的 主 要 原 因 之 一 与 把 异 常 传 入 嵌 套 的 协 程 有 关。 另 一 个 原 因 是 让 协 程 更 方 便 地 返 回 值。</div>
<div class='sectionHeading'>16.6　让协程返回值</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14084</div><div class='noteText'>return 表 达 式 的 值 会 偷 偷 传 给 调 用 方， 赋 值 给 StopIteration 异 常 的 一 个 属 性。 这 样 做 有 点 不 合 常 理， 但 是 能 保 留 生 成 器 对 象 的 常 规 行 为—— 耗 尽 时 抛 出 StopIteration 异 常。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14094</div><div class='noteText'>获 取 协 程 的 返 回 值 虽 然 要 绕 个 圈 子， 但 这 是 PEP 380 定 义 的 方 式， 当 我 们 意 识 到 这 一 点 之 后 就 说 得 通 了： yield from 结 构 会 在 内 部 自 动 捕 获 StopIteration 异 常。 这 种 处 理 方 式 与 for 循 环 处 理 StopIteration 异 常 的 方 式 一 样： 循 环 机 制 使 用 用 户 易 于 理 解 的 方 式 处 理 异 常。 对 yield from 结 构 来 说， 解 释 器 不 仅 会 捕 获 StopIteration 异 常， 还 会 把 value 属 性 的 值 变 成 yield from 表 达 式 的 值。</div>
<div class='sectionHeading'>16.7　使用yield from</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14114</div><div class='noteText'>首 先 要 知 道， yield from 是 全 新 的 语 言 结 构。 它 的 作 用 比 yield 多 很 多， 因 此 人 们 认 为 继 续 使 用 那 个 关 键 字 多 少 会 引 起 误 解。 在 其 他 语 言 中， 类 似 的 结 构 使 用 await 关 键 字， 这 个 名 称 好 多 了， 因 为 它 传 达 了 至 关 重 要 的 一 点： 在 生 成 器 gen 中 使 用 yield from subgen() 时， subgen 会 获 得 控 制 权， 把 产 出 的 值 传 给 gen 的 调 用 方， 即 调 用 方 可 以 直 接 控 制 subgen。 与 此 同 时， gen 会 阻 塞， 等 待 subgen 终 止。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14127</div><div class='noteText'>yield from 可 用 于 简 化 for 循 环 中 的 yield 表 达 式。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14140</div><div class='noteText'>yield from 链 接 可 迭 代 的 对 象</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14148</div><div class='noteText'>yield from x 表 达 式 对 x 对 象 所 做 的 第 一 件 事 是， 调 用 iter( x)，</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14149</div><div class='noteText'>从 中 获 取 迭 代 器。 因 此， x 可 以 是 任 何 可 迭 代 的 对 象。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14153</div><div class='noteText'>yield from 结 构 的 本 质 作 用 无 法 通 过 简 单 的 可 迭 代 对 象 说 明， 而 要 发 散 思 维， 使 用 嵌 套 的 生 成 器。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14154</div><div class='noteText'>引 入 yield from 结 构 的 PEP 380 才 起 了“ Syntax for Delegating to a Subgenerator”（“ 把 职 责 委 托 给 子 生 成 器 的 句 法”） 这 个 标 题。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14157</div><div class='noteText'>yield from 的 主 要 功 能 是 打 开 双 向 通 道， 把 最 外 层 的 调 用 方 与 最 内 层 的 子 生 成 器 连 接 起 来， 这 样 二 者 可 以 直 接 发 送 和 产 出 值， 还 可 以 直 接 传 入 异 常， 而 不 用 在 位 于 中 间 的 协 程 中 添 加 大 量 处 理 异 常 的 样 板 代 码。 有 了 这 个 结 构， 协 程 可 以 通 过 以 前 不 可 能 的 方 式 委 托 职 责。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14174</div><div class='noteText'>不 过， 引 入 yield from 结 构 的 目 的 是 为 了 支 持 实 现 了 __next__、 send、 close 和 throw 方 法 的 生 成 器。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14252</div><div class='noteText'>强 调 这 行 代 码（ group.send( None)） 至 关 重 要： 终 止 当 前 的 averager 实 例， 开 始 执 行 下 一 个。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14290</div><div class='noteText'>这 个 试 验 想 表 明 的 关 键 一 点 是， 如 果 子 生 成 器 不 终 止， 委 派 生 成 器 会 在 yield from 表 达 式 处 永 远 暂 停。 如 果 是 这 样， 程 序 不 会 向 前 执 行， 因 为 yield from（ 与 yield 一 样） 把 控 制 权 转 交 给 客 户 代 码（ 即， 委 派 生 成 器 的 调 用 方） 了。 显 然， 肯 定 有 任 务 无 法 完 成。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14296</div><div class='noteText'>因 为 委 派 生 成 器 相 当 于 管 道， 所 以 可 以 把 任 意 数 量 个 委 派 生 成 器 连 接 在 一 起： 一 个 委 派 生 成 器 使 用 yield from 调 用 一 个 子 生 成 器， 而 那 个 子 生 成 器 本 身 也 是 委 派 生 成 器， 使 用 yield from 调 用 另 一 个 子 生 成 器， 以 此 类 推。 最 终， 这 个 链 条 要 以 一 个 只 使 用 yield 表 达 式 的 简 单 生 成 器 结 束； 不 过， 也 能 以 任 何 可 迭 代 的 对 象 结 束，</div>
<div class='sectionHeading'>16.8　yield from的意义</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14414</div><div class='noteText'>如 果 子 生 成 器 实 现 了 这 两 个 方 法， 而 在 子 生 成 器 内 部， 这 两 个 方 法 都 会 触 发 异 常 抛 出， 这 种 情 况 也 必 须 由 yield from 机 制 处 理。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14415</div><div class='noteText'>调 用 方 可 能 会 无 缘 无 故 地 让 子 生 成 器 自 己 抛 出 异 常， 实 现 yield from 结 构 时 也 必 须 处 理 这 种 情 况。 最 后， 为 了 优 化， 如 果 调 用 方 调 用 next(...) 函 数 或 .send( None) 方 法， 都 要 转 交 职 责， 在 子 生 成 器 上 调 用 next(...) 函 数； 仅 当 调 用 方 发 送 的 值 不 是 None 时， 才 使 用 子 生 成 器 的 .send(...) 方 法。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14478</div><div class='noteText'>这 段 yield from 伪 代 码 的 大 多 数 逻 辑 通 过 六 个 try/ except 块 实 现， 而 且 嵌 套 了 四 层， 因 此 有 点 难 以 阅 读。 此 外， 用 到 的 其 他 流 程 控 制 关 键 字 有 一 个 while、 一 个 if 和 一 个 yield。 找 到 while 循 环、 yield 表 达 式 以 及 next(...) 函 数 和 .send(...) 方 法 调 用， 这 些 代 码 有 助 于 对 yield from 结 构 的 运 作 方 式 有 个 整 体 的 了 解。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14487</div><div class='noteText'>有 行 代 码（ 标 号 ❷） 揭 示 了 一 个 重 要 的 细 节： 要 预 激 子 生 成 器。 9 这 表 明， 用 于 自 动 预 激 的 装 饰 器（ 如 16.4 节 定 义 的 那 个） 与 yield from 结 构 不 兼 容。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14495</div><div class='noteText'>我 不 是 让 你 通 过 扩 充 的 伪 代 码 学 习 这 个 结 构， 那 段 伪 代 码 是 为 了 让 语 言 专 家 弄 明 白 细 节。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14498</div><div class='noteText'>我 见 过 的 yield from 示 例 几 乎 都 使 用 asyncio 模 块 做 异 步 编 程， 因 此 要 有 有 效 的 事 件 循 环 才 能 运 行。</div>
<div class='sectionHeading'>16.9　使用案例：使用协程做离散事件仿真</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14505</div><div class='noteText'>协 程 能 自 然 地 表 述 很 多 算 法， 例 如 仿 真、 游 戏、 异 步 I/ O， 以 及 其 他 事 件 驱 动 型 编 程 形 式 或 协 作 式 多 任 务。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14510</div><div class='noteText'>在 计 算 机 科 学 领 域， 仿 真 是 协 程 的 经 典 应 用。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14512</div><div class='noteText'>协 程 是 asyncio 包 的 基 础 构 建。 通 过 仿 真 系 统 能 说 明 如 何 使 用 协 程 代 替 线 程 实 现 并 发 的 活 动， 而 且 对 理 解 第 18 章 讨 论 的 asyncio 包 有 极 大 的 帮 助。</div>
<div class='sectionHeading'>16.9.1　离散事件仿真简介</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14521</div><div class='noteText'>显 然， 回 合 制 游 戏 就 是 离 散 事 件 仿 真 的 例 子： 游 戏 的 状 态 只 在 玩 家 操 作 时 变 化， 而 且 一 旦 玩 家 决 定 下 一 步 怎 么 走 了， 仿 真 钟 就 会 冻 结。 而 实 时 游 戏 则 是 连 续 仿 真， 仿 真 钟 一 直 在 运 行， 游 戏 的 状 态 在 一 秒 钟 之 内 更 新 很 多 次， 因 此 反 应 慢 的 玩 家 特 别 吃 亏。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14530</div><div class='noteText'>在 仿 真 领 域， 进 程 这 个 术 语 指 代 模 型 中 某 个 实 体 的 活 动， 与 操 作 系 统 中 的 进 程 无 关。 仿 真 系 统 中 的 一 个 进 程 可 以 使 用 操 作 系 统 中 的 一 个 进 程 实 现， 但 是 通 常 会 使 用 一 个 线 程 或 一 个 协 程 实 现。</div>
<div class='sectionHeading'>16.9.2　出租车队运营仿真</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14646</div><div class='noteText'>在 这 个 仿 真 系 统 中， 各 个 出 租 车 协 程 由 Simulator.run 方 法 中 的 主 循 环 驱 动。 仿 真“ 钟” 保 存 在 sim_time 变 量 中， 每 次 产 出 事 件 时 都 会 更 新 仿 真 钟。</div>
<div class='sectionHeading'>16.10　本章小结</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14796</div><div class='noteText'>生 成 器 有 三 种 不 同 的 代 码 编 写 风 格： 有 传 统 的“ 拉 取 式”（ 迭 代 器）、“ 推 送 式”（ 例 如 计 算 平 均 值 那 个 示 例）， 还 有“ 任 务 式”（</div>
<div class='sectionHeading'>16.11　延伸阅读</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14890</div><div class='noteText'>为 Python 增 加 两 个 关 键 字： async 和 await。 async 与 其 他 现 有 的 关 键 字 结 合 使 用， 用 于 定 义 新 的 语 言 结 构。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14897</div><div class='noteText'>为 了 避 免 与 即 将 引 入 的 async 关 键 字 冲 突， asyncio.async() 函 数 将 在 Python 3.4.4 中 重 命 名 为 asyncio.ensure_future()。 await 关 键 字 的 作 用 与 yield from 结 构 类 似， 不 过 只 能 在 以 async def 定 义 的 协 程（ 禁 止 使 用 yield 和 yield from） 中 使 用。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 14905</div><div class='noteText'>得 益 于 async 和 await 关 键 字， 以 及 几 个 特 殊 的 新 方 法， Python 语 言 将 对 原 生 的 协 程 对 象 提 供 更 好 的 支 持。 协 程 已 经 做 好 准 备， 会 成 为 Python 未 来 特 别 重 要 的 特 性， 因 此 Python 语 言 应 该 更 好 地 集 成 协 程。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15002</div><div class='noteText'>完 成 本 书 的 技 术 审 校 之 后， Yury Selivanov 提 交 的“ PEP 492 — Coroutines with async and await syntax” 好 像 要 被 接 受 了， 将 在 Python 3.5 中 实 现。</div>
<div class='sectionHeading'>17.1　示例：网络下载的三种风格</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15067</div><div class='noteText'>在 I/ O 密 集 型 应 用 中， 如 果 代 码 写 得 正 确， 那 么 不 管 使 用 哪 种 并 发 策 略（ 使 用 线 程 或 asyncio 包）， 吞 吐 量 都 比 依 序 执 行 的 代 码 高 很 多。</div>
<div class='sectionHeading'>17.1.2　使用concurrent.futures模块下载</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15125</div><div class='noteText'>concurrent.futures 模 块 的 主 要 特 色 是 ThreadPoolExecutor 和 ProcessPoolExecutor 类， 这 两 个 类 实 现 的 接 口 能 分 别 在 不 同 的 线 程 或 进 程 中 执 行 可 调 用 的 对 象。 这 两 个 类 在 内 部 维 护 着 一 个 工 作 线 程 或 进 程 池， 以 及 要 执 行 的 任 务 队 列。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15160</div><div class='noteText'>编 写 并 发 代 码 时 经 常 这 样 重 构： 把 依 序 执 行 的 for 循 环 体 改 成 函 数， 以 便 并 发 调 用。</div>
<div class='sectionHeading'>17.1.3　期物在哪里</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15170</div><div class='noteText'>两 个 Future 类 的 实 例 都 表 示 可 能 已 经 完 成 或 者 尚 未 完 成 的 延 迟 计 算。 这 与 Twisted 引 擎 中 的 Deferred 类、 Tornado 框 架 中 的 Future 类， 以 及 多 个 JavaScript 库 中 的 Promise 对 象 类 似。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15176</div><div class='noteText'>通 常 情 况 下 自 己 不 应 该 创 建 期 物， 而 只 能 由 并 发 框 架（ concurrent.futures 或 asyncio） 实 例 化。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15178</div><div class='noteText'>期 物 表 示 终 将 发 生 的 事 情， 而 确 定 某 件 事 会 发 生 的 唯 一 方 式 是 执 行 的 时 间 已 经 排 定。 因 此， 只 有 排 定 把 某 件 事 交 给 concurrent.futures.Executor 子 类 处 理 时， 才 会 创 建 concurrent.futures.Future 实 例。 例 如， Executor.submit() 方 法 的 参 数 是 一 个 可 调 用 的 对 象， 调 用 这 个 方 法 后 会 为 传 入 的 可 调 用 对 象 排 期， 并 返 回 一 个 期 物。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15183</div><div class='noteText'>客 户 端 代 码 不 应 该 改 变 期 物 的 状 态， 并 发 框 架 在 期 物 表 示 的 延 迟 计 算 结 束 后 会 改 变 期 物 的 状 态， 而 我 们 无 法 控 制 计 算 何 时 结 束。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15187</div><div class='noteText'>两 个 Future 类 都 有 .add_done_callback() 方 法： 这 个 方 法 只 有 一 个 参 数， 类 型 是 可 调 用 的 对 象， 期 物 运 行 结 束 后 会 调 用 指 定 的 可 调 用 对 象。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15189</div><div class='noteText'>还 有 .result() 方 法。 在 期 物 运 行 结 束 后 调 用 的 话， 这 个 方 法 在 两 个 Future 类 中 的 作 用 相 同： 返 回 可 调 用 对 象 的 结 果， 或 者 重 新 抛 出 执 行 可 调 用 的 对 象 时 抛 出 的 异 常。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15192</div><div class='noteText'>如 果 期 物 没 有 运 行 结 束， result 方 法 在 两 个 Future 类 中 的 行 为 相 差 很 大。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15194</div><div class='noteText'>大。 对 concurrency.futures.Future 实 例 来 说， 调 用 f.result() 方 法 会 阻 塞 调 用 方 所 在 的 线 程， 直 到 有 结 果 可 返 回。 此 时， result 方 法 可 以 接 收 可 选 的 timeout 参 数， 如 果 在 指 定 的 时 间 内 期 物 没 有 运 行 完 毕， 会 抛 出 TimeoutError 异 常。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15199</div><div class='noteText'>asyncio.Future.result 方 法 不 支 持 设 定 超 时 时 间， 在 那 个 库 中 获 取 期 物 的 结 果 最 好 使 用 yield from 结 构。 不 过， 对 concurrency.futures.Future 实 例 不 能 这 么 做。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15204</div><div class='noteText'>返 回 值 是 一 个 迭 代 器， 迭 代 器 的 __next__ 方 法 调 用 各 个 期 物 的 result 方 法， 因 此 我 们 得 到 的 是 各 个 期 物 的 结 果， 而 非 期 物 本 身。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15277</div><div class='noteText'>GIL 几 乎 对 I/ O 密 集 型 处 理 无 害，</div>
<div class='sectionHeading'>17.2　阻塞型I/O和GIL</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15278</div><div class='noteText'>CPython 解 释 器 本 身 就 不 是 线 程 安 全 的， 因 此 有 全 局 解 释 器 锁（ GIL）， 一 次 只 允 许 使 用 一 个 线 程 执 行 Python 字 节 码。 因 此， 一 个 Python 进 程 通 常 不 能 同 时 使 用 多 个 CPU 核 心。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15280</div><div class='noteText'>这 是 CPython 解 释 器 的 局 限， 与 Python 语 言 本 身 无 关。 Jython 和 IronPython 没 有 这 种 限 制。 不 过， 目 前 最 快 的 Python 解 释 器 PyPy 也 有 GIL。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15282</div><div class='noteText'>编 写 Python 代 码 时 无 法 控 制 GIL； 不 过， 执 行 耗 时 的 任 务 时， 可 以 使 用 一 个 内 置 的 函 数 或 一 个 使 用 C 语 言 编 写 的 扩 展 释 放 GIL。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15283</div><div class='noteText'>有 个 使 用 C 语 言 编 写 的 Python 库 能 管 理 GIL， 自 行 启 动 操 作 系 统 线 程， 利 用 全 部 可 用 的 CPU 核 心。 这 样 做 会 极 大 地 增 加 库 代 码 的 复 杂 度， 因 此 大 多 数 库 的 作 者 都 不 这 么 做。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15285</div><div class='noteText'>标 准 库 中 所 有 执 行 阻 塞 型 I/ O 操 作 的 函 数， 在 等 待 操 作 系 统 返 回 结 果 时 都 会 释 放 GIL。 这 意 味 着 在 Python 语 言 这 个 层 次 上 可 以 使 用 多 线 程， 而 I/ O 密 集 型 Python 程 序 能 从 中 受 益： 一 个 Python 线 程 等 待 网 络 响 应 时， 阻 塞 型 I/ O 函 数 会 释 放 GIL， 再 运 行 一 个 线 程。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15288</div><div class='noteText'>Python 线 程 毫 无 作 用。”</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15291</div><div class='noteText'>Python 标 准 库 中 的 所 有 阻 塞 型 I/ O 函 数 都 会 释 放 GIL， 允 许 其 他 线 程 运 行。 time.sleep() 函 数 也 会 释 放 GIL。 因 此， 尽 管 有 GIL， Python 线 程 还 是 能 在 I/ O 密 集 型 应 用 中 发 挥 作 用。</div>
<div class='sectionHeading'>17.3　使用concurrent.futures模块启动进程</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15298</div><div class='noteText'>这 个 模 块 实 现 的 是 真 正 的 并 行 计 算， 因 为 它 使 用 ProcessPoolExecutor 类 把 工 作 分 配 给 多 个 Python 进 程 处 理。 因 此， 如 果 需 要 做 CPU 密 集 型 处 理， 使 用 这 个 模 块 能 绕 开 GIL， 利 用 所 有 可 用 的 CPU 核 心。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15302</div><div class='noteText'>因 此 使 用 concurrent.futures 模 块 能 特 别 轻 松 地 把 基 于 线 程 的 方 案 转 成 基 于 进 程 的 方 案。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15318</div><div class='noteText'>程。 而 对 I/ O 密 集 型 处 理 来 说， 可 以 在 一 个 ThreadPoolExecutor 实 例 中 使 用 10 个、 100 个 或 1000 个 线 程； 最 佳 线 程 数 取 决 于 做 的 是 什 么 事， 以 及 可 用 内 存 有 多 少， 因 此 要 仔 细 测 试 才 能 找 到 最 佳 的 线 程 数。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15325</div><div class='noteText'>ProcessPoolExecutor 的 价 值 体 现 在 CPU 密 集 型 作 业 上。 我 用 两 个 CPU 密 集 型 脚 本 做 了 一 些 性 能 测 试。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15360</div><div class='noteText'>如 果 使 用 Python 处 理 CPU 密 集 型 工 作， 应 该 试 试 PyPy。 使 用 PyPy 运 行 arcfour_futures.py 脚 本， 速 度 快 了 3.8 ~ 5.1 倍； 具 体 的 倍 数 由 职 程 的 数 量 决 定。 我 测 试 时 使 用 的 是 PyPy 2.4.0， 这 一 版 与 Python 3.2.5 兼 容， 因 此 标 准 库 中 有 concurrent.futures 模 块。</div>
<div class='sectionHeading'>17.4　实验Executor.map方法</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15396</div><div class='noteText'>这 个 函 数 又 会 在（ 内 部） 表 示 第 一 个 任 务（ loiter( 0)） 的 _f 期 物 上 调 用 _f.result() 方 法。 result 方 法 会 阻 塞， 直 到 期 物 运 行 结 束，</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15399</div><div class='noteText'>因 此 这 个 循 环 每 次 迭 代 时 都 要 等 待 下 一 个 结 果 做 好 准 备。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15446</div><div class='noteText'>Executor.map 函 数 易 于 使 用， 不 过 有 个 特 性 可 能 有 用， 也 可 能 没 用， 具 体 情 况 取 决 于 需 求： 这 个 函 数 返 回 结 果 的 顺 序 与 调 用 开 始 的 顺 序 一 致。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15450</div><div class='noteText'>不 过， 通 常 更 可 取 的 方 式 是， 不 管 提 交 的 顺 序， 只 要 有 结 果 就 获 取。 为 此， 要 把 Executor.submit 方 法 和 futures.as_completed 函 数 结 合 起 来 使 用，</div>
<div class='sectionHeading'>17.5.2　使用futures.as_completed函数</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15741</div><div class='noteText'>Python 线 程 特 别 适 合 I/ O 密 集 型 应 用，</div>
<div class='sectionHeading'>17.5.3　线程和多进程的替代方案</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15747</div><div class='noteText'>concurrent.futures 只 不 过 是 使 用 线 程 的 最 新 方 式。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15761</div><div class='noteText'>对 CPU 密 集 型 工 作 来 说， 要 启 动 多 个 进 程， 规 避 GIL。 创 建 多 个 进 程 最 简 单 的 方 式 是， 使 用 futures.ProcessPoolExecutor 类。 不 过 和 前 面 一 样， 如 果 使 用 场 景 较 复 杂， 需 要 更 高 级 的 工 具。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15764</div><div class='noteText'>multiprocessing 模 块 的 API 与 threading 模 块 相 仿， 不 过 作 业 交 给 多 个 进 程 处 理。 对 简 单 的 程 序 来 说， 可 以 用 multiprocessing 模 块 代 替 threading 模 块， 少 量 改 动 即 可。 不 过， multiprocessing 模 块 还 能 解 决 协 作 进 程 遇 到 的 最 大 挑 战： 在 进 程 之 间 传 递 数 据。</div>
<div class='sectionHeading'>17.7　延伸阅读</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15840</div><div class='noteText'>对 于 CPU 密 集 型 和 数 据 密 集 型 并 行 处 理， 现 在 有 个 新 工 具 可 用—— 分 布 式 计 算 引 擎 Apache Spark。 Spark 在 大 数 据 领 域 发 展 势 头 强 劲， 提 供 了 友 好 的 Python API， 支 持 把 Python 对 象 当 作 数 据，</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15852</div><div class='noteText'>远 离 线 程</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15863</div><div class='noteText'>过 去 七 年 我 觉 得 让 人 眼 前 一 亮 的 编 程 语 言（ 包 括 Go、 Elixir 和 Clojure） 都 对 并 发 做 了 更 好、 更 高 层 的 抽 象，</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15879</div><div class='noteText'>直 到 发 现 标 准 库 中 每 一 个 阻 塞 型 I/ O 函 数 都 会 释 放 GIL 之 后， 我 才 意 识 到 Python 线 程 特 别 适 合 在 I/ O 密 集 型 系 统（</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15883</div><div class='noteText'>Ruby 和 JavaScript 是 最 能 直 接 与 Python 竞 争 的 通 用 动 态 编 程 语 言。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15884</div><div class='noteText'>Go 和 Elixir 或 许 是 最 能 蚕 食 Python 的 语 言。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15885</div><div class='noteText'>现 在 有 asyncio 了。 既 然 这 么 多 人 相 信 纯 粹 使 用 回 调 的 Node.js 平 台 可 以 做 并 发 编 程， 那 么 asyncio 生 态 系 统 成 熟 后， Python 赢 回 这 些 人 能 有 多 难 呢？</div>
<div class='sectionHeading'>第 18 章　使用 asyncio 包处理并发</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15905</div><div class='noteText'>本 章 介 绍 asyncio 包， 这 个 包 使 用 事 件 循 环 驱 动 的 协 程 实 现 并 发。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15925</div><div class='noteText'>对 比 一 个 简 单 的 多 线 程 程 序 和 对 应 的 asyncio 版， 说 明 多 线 程 和 异 步 任 务 之 间 的 关 系</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15930</div><div class='noteText'>摒 弃 线 程 或 进 程， 如 何 使 用 异 步 编 程 管 理 网 络 应 用 中 的 高 并 发</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15931</div><div class='noteText'>在 异 步 编 程 中， 与 回 调 相 比， 协 程 显 著 提 升 性 能 的 方 式</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15932</div><div class='noteText'>如 何 把 阻 塞 的 操 作 交 给 线 程 池 处 理， 从 而 避 免 阻 塞 事 件 循 环</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15933</div><div class='noteText'>使 用 asyncio 编 写 服 务 器， 重 新 审 视 Web 应 用 对 高 并 发 的 处 理 方 式</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15934</div><div class='noteText'>为 什 么 asyncio 已 经 准 备 好 对 Python 生 态 系 统 产 生 重 大 影 响</div>
<div class='sectionHeading'>18.1　线程与协程对比</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15995</div><div class='noteText'>asyncio 包 使 用 的“ 协 程” 是 较 严 格 的 定 义。 适 合 asyncio API 的 协 程 在 定 义 体 中 必 须 使 用 yield from， 而 不 能 使 用 yield。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 15998</div><div class='noteText'>适 合 asyncio 的 协 程 要 由 调 用 方 驱 动， 并 由 调 用 方 通 过 yield from 调 用； 或 者 把 协 程 传 给 asyncio 包 中 的 某 个 函 数， 例 如 asyncio.async(...) 和 本 章 要 介 绍 的 其 他 函 数， 从 而 驱 动 协 程。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16002</div><div class='noteText'>后，@ asyncio.coroutine 装 饰 器 应 该 应 用 在 协 程 上，</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16010</div><div class='noteText'>except asyncio.CancelledError: ➍ break</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16018</div><div class='noteText'>打 算 交 给 asyncio 处 理 的 协 程 要 使 用 @asyncio.coroutine 装 饰。 这 不 是 强 制 要 求， 但 是 强 烈 建 议 这 么</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16050</div><div class='noteText'>除 非 想 阻 塞 主 线 程， 从 而 冻 结 事 件 循 环 或 整 个 应 用， 否 则 不 要 在 asyncio 协 程 中 使 用 time.sleep(...)。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16052</div><div class='noteText'>如 果 协 程 需 要 在 一 段 时 间 内 什 么 也 不 做， 应 该 使 用 yield from</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16053</div><div class='noteText'>asyncio.sleep( DELAY)。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16053</div><div class='noteText'>使 用 @asyncio.coroutine 装 饰 器 不 是 强 制 要 求， 但 是 强 烈 建 议 这 么 做， 因 为 这 样 能 在 一 众 普 通 的 函 数 中 把 协 程 凸 显 出 来， 也 有 助 于 调 试： 如 果 还 没 从 中 产 出 值， 协 程 就 被 垃 圾 回 收 了（ 意 味 着 有 操 作 未 完 成， 因 此 有 可 能 是 个 缺 陷）， 那 就 可 以 发 出 警 告。 这 个 装 饰 器 不 会 预 激 协 程。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16077</div><div class='noteText'>出，“ Task 对 象 像 是 实 现 协 作 式 多 任 务 的 库（ 例 如 gevent） 中 的 绿 色 线 程（ green thread）”。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16090</div><div class='noteText'>在 异 步 版 supervisor 函 数 中， slow_function 函 数 是 协 程， 由 yield from 驱 动。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16093</div><div class='noteText'>如 果 想 终 止 任 务， 可 以 使 用 Task.cancel() 实 例 方 法，</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16094</div><div class='noteText'>在 协 程 内 部 抛 出 CancelledError 异 常。 协 程 可 以 在 暂 停 的 yield 处 捕 获 这 个 异 常， 处 理 终 止 请 求。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16097</div><div class='noteText'>协 程 必 须 在 main 函 数 中 由 loop.run_until_complete 方 法 执 行。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16104</div><div class='noteText'>协 程 默 认 会 做 好 全 方 位 保 护， 以 防 止 中 断。 我 们 必 须 显 式 产 出 才 能 让 程 序 的 余 下 部 分 运 行。 对 协 程 来 说， 无 需 保 留 锁， 在 多 个 线 程 之 间 同 步 操 作， 协 程 自 身 就 会 同 步， 因 为 在 任 意 时 刻 只 有 一 个 协 程 运 行。 想 交 出 控 制 权 时， 可 以 使 用 yield 或 yield from 把 控 制 权 交 还 调 度 程 序。 这 就 是 能 够 安 全 地 取 消 协 程 的 原 因： 按 照 定 义， 协 程 只 能 在 暂 停 的 yield 处 取 消， 因 此 可 以 处 理 CancelledError 异 常， 执 行 清 理 操 作。</div>
<div class='sectionHeading'>18.1.1　asyncio.Future：故意不阻塞</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16115</div><div class='noteText'>不 过 实 现 方 式 不 同， 不 可 以 互 换。“</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16136</div><div class='noteText'>如 果 调 用 .result() 方 法 时 期 物 还 没 运 行 完 毕， 那 么 .result() 方 法 不 会 阻 塞 去 等 待 结 果， 而 是 抛 出 asyncio.InvalidStateError 异 常。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16139</div><div class='noteText'>获 取 asyncio.Future 对 象 的 结 果 通 常 使 用 yield from， 从 中 产 出 结 果，</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16141</div><div class='noteText'>使 用 yield from 处 理 期 物， 等 待 期 物 运 行 完 毕 这 一 步 无 需 我 们 关 心， 而 且 不 会 阻 塞 事 件 循 环， 因 为 在 asyncio 包 中， yield from 的 作 用 是 把 控 制 权 还 给 事 件 循 环。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16145</div><div class='noteText'>使 用 yield from 处 理 期 物 与 使 用 add_done_callback 方 法 处 理 协 程 的 作 用 一 样： 延 迟 的 操 作 结 束 后， 事 件 循 环 不 会 触 发 回 调 对 象， 而 是 设 置 期 物 的 返 回 值；</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16147</div><div class='noteText'>而 yield from 表 达 式 则 在 暂 停 的 协 程 中 生 成 返 回 值， 恢 复 执 行 协 程。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16152</div><div class='noteText'>因 为 可 以 直 接 把 想 在 期 物 运 行 结 束 后 执 行 的 操 作 放 在 协 程 中 yield from my_future 表 达 式 的 后 面。 这 是 协 程 的 一 大 优 势： 协 程 是 可 以 暂 停 和 恢 复 的 函 数。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16155</div><div class='noteText'>因 为 yield from 从 期 物 中 产 出 的 值 就 是 结 果（ 例 如， result = yield from my_future）。</div>
<div class='sectionHeading'>18.1.2　从期物、任务和协程中产出</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16164</div><div class='noteText'>在 asyncio 包 中， 期 物 和 协 程 关 系 紧 密， 因 为 可 以 使 用 yield from 从 asyncio.Future 对 象 中 产 出 结 果。 这 意 味 着， 如 果 foo 是 协 程 函 数（ 调 用 后 返 回 协 程 对 象）， 抑 或 是 返 回 Future 或 Task 实 例 的 普 通 函 数， 那 么 可 以 这 样 写： res = yield from foo()。 这 是 asyncio 包 的 API 中 很 多 地 方 可 以 互 换 协 程 与 期 物 的 原 因 之</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16172</div><div class='noteText'>为 了 执 行 这 些 操 作， 必 须 排 定 协 程 的 运 行 时 间， 然 后 使 用 asyncio.Task 对 象 包 装 协 程。 对 协 程 来 说， 获 取 Task 对 象 有 两 种 主 要 方 式。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16176</div><div class='noteText'>　 这 个 函 数 统 一 了 协 程 和 期 物： 第 一 个 参 数 可 以 是 二 者 中 的 任 何 一 个。 如 果 是 Future 或 Task 对 象， 那 就 原 封 不 动 地 返 回。 如 果 是 协 程， 那 么 async 函 数 会 调 用 loop.create_task(...) 方 法 创 建 Task</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16180</div><div class='noteText'>对 象。 loop = 关 键 字 参 数 是 可 选 的， 用 于 传 入 事 件 循 环； 如 果 没 有 传 入， 那 么 async 函 数 会 通 过 调 用 asyncio.get_event_loop() 函 数 获 取 循 环 对 象。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16185</div><div class='noteText'>这 个 方 法 排 定 协 程 的 执 行 时 间， 返 回 一 个 asyncio.Task 对 象。 如 果 在 自 定 义 的 BaseEventLoop 子 类 上 调 用， 返 回 的 对 象 可 能 是 外 部 库（ 如 Tornado） 中 与 Task 类 兼 容 的 某 个 类 的 实 例。</div>
<div class='sectionHeading'>18.2　使用asyncio和aiohttp包下载</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16262</div><div class='noteText'>虽 然 函 数 的 名 称 是 wait， 但 它 不 是 阻 塞 型 函 数。 wait 是 一 个 协 程， 等 传 给 它 的 所 有 协 程 运 行 完 毕 后 结 束（</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16270</div><div class='noteText'>实 际 情 况 是 复 杂 的， 客 户 代 码 绝 不 会 直 接 创 建 事 件 循 环， 而 是 调 用 asyncio.get_event_loop() 函 数， 获 取 事 件 循 环 的 引 用。 而 且 有 时 我 们 的 代 码 不“ 拥 有” 事 件 循 环， 因 此 关 闭 事 件 循 环 会 出 错。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16282</div><div class='noteText'>loop.run_until_complete 方 法 的 参 数 是 一 个 期 物 或 协 程。 如 果 是 协 程， run_until_complete 方 法 与 wait 函 数 一 样， 把 协 程 包 装 进 一 个 Task 对 象 中。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16285</div><div class='noteText'>协 程、 期 物 和 任 务 都 能 由 yield from 驱 动， 这 正 是 run_until_complete 方 法 对 wait 函 数 返 回 的 wait_coro 对 象 所 做 的 事。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16328</div><div class='noteText'>使 用 yield from 链 接 的 多 个 协 程 最 终 必 须 由 不 是 协 程 的 调 用 方 驱 动， 调 用 方 显 式 或 隐 式（ 例 如， 在 for 循 环 中） 在 最 外 层 委 派 生 成 器 上 调 用 next(...) 函 数 或 .send(...) 方 法。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16332</div><div class='noteText'>链 条 中 最 内 层 的 子 生 成 器 必 须 是 简 单 的 生 成 器（ 只 使 用 yield） 或 可 迭 代 的 对 象。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16336</div><div class='noteText'>我 们 编 写 的 协 程 链 条 始 终 通 过 把 最 外 层 委 派 生 成 器 传 给 asyncio 包 API 中 的 某 个 函 数（ 如 loop.run_until_complete(...)） 驱 动。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16338</div><div class='noteText'>也 就 是 说， 使 用 asyncio 包 时， 我 们 编 写 的 代 码 不 通 过 调 用 next(...) 函 数 或 .send(...) 方 法 驱 动 协 程—— 这 一 点 由 asyncio 包 实 现 的 事 件 循 环 去 做。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16342</div><div class='noteText'>我 们 编 写 的 协 程 链 条 最 终 通 过 yield from 把 职 责 委 托 给 asyncio 包 中 的 某 个 协 程 函 数 或 协 程 方 法（ 例 如 示 例 18-2 中 的 yield from asyncio.sleep(...)）， 或 者 其 他 库 中 实 现 高 层 协 议 的 协 程（ 例 如 示 例 18-5 中 get_flag 协 程 里 的 resp = yield from aiohttp. request(' GET', url)）。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16348</div><div class='noteText'>也 就 是 说， 最 内 层 的 子 生 成 器 是 库 中 真 正 执 行 I/ O 操 作 的 函 数， 而 不 是 我 们 自 己 编 写 的 函 数。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16349</div><div class='noteText'>使 用 asyncio 包 时， 我 们 编 写 的 异 步 代 码 中 包 含 由 asyncio 本 身 驱 动 的 协 程（ 即 委 派 生 成 器）， 而 生 成 器 最 终 把 职 责 委 托 给 asyncio 包 或 第 三 方 库（ 如 aiohttp） 中 的 协 程。 这 种 处 理 方 式 相 当 于 架 起 了 管 道， 让 asyncio 事 件 循 环（ 通 过 我 们 编 写 的 协 程） 驱 动 执 行 低 层 异 步 I/ O 操 作 的 库 函 数。</div>
<div class='sectionHeading'>18.3　避免阻塞型调用</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16357</div><div class='noteText'>Ryan Dahl（ Node.js 的 发 明 者） 在 介 绍 他 的 项 目 背 后 的 哲 学 时 说：“ 我 们 处 理 I/ O 的 方 式 彻 底 错 了。” 5 他 把 执 行 硬 盘 或 网 络 I/ O 操 作 的 函 数 定 义 为 阻 塞 型 函 数， 主 张 不 能 像 对 待 非 阻 塞 型 函 数 那 样 对 待 阻 塞 型 函 数。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16382</div><div class='noteText'>有 两 种 方 法 能 避 免 阻 塞 型 调 用 中 止 整 个 应 用 程 序 的 进 程：</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16383</div><div class='noteText'>在 单 独 的 线 程 中 运 行 各 个 阻 塞 型 操 作</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16383</div><div class='noteText'>把 每 个 阻 塞 型 操 作 转 换 成 非 阻 塞 的 异 步 调 用 使 用</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16386</div><div class='noteText'>为 了 降 低 内 存 的 消 耗， 通 常 使 用 回 调 来 实 现 异 步 调 用。 这 是 一 种 低 层 概 念， 类 似 于 所 有 并 发 机 制 中 最 古 老、 最 原 始 的 那 种—— 硬 件 中 断。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16388</div><div class='noteText'>使 用 回 调 时， 我 们 不 等 待 响 应， 而 是 注 册 一 个 函 数， 在 发 生 某 件 事 时 调 用。 这 样， 所 有 调 用 都 是 非 阻 塞 的。 因 为 回 调 简 单， 而 且 消 耗 低， 所 以 Ryan Dahl 拥 护 这 种 方 式。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16392</div><div class='noteText'>过， 如 果 做 法 正 确， 事 件 循 环 和 应 用 代 码 共 用 的 主 线 程 绝 不 会 阻 塞。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16396</div><div class='noteText'>把 生 成 器 当 作 协 程 使 用 是 异 步 编 程 的 另 一 种 方 式。 对 事 件 循 环 来 说， 调 用 回 调 与 在 暂 停 的 协 程 上 调 用 .send() 方 法 效 果 差 不 多。 各 个 暂 停 的 协 程 是 要 消 耗 内 存， 但 是 比 线 程 消 耗 的 内 存 数 量 级 小。 而 且， 协 程 能 避 免 可 怕 的“ 回 调 地 狱”；</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16407</div><div class='noteText'>这 些 调 用 都 不 会 阻 塞， 因 此 在 零 点 几 秒 内 所 有 请 求 全 部 开 始。</div>
<div class='sectionHeading'>18.4.1　使用asyncio.as_completed函数</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16451</div><div class='noteText'>因 为 在 使 用 asyncio 包 的 程 序 中 只 有 一 个 主 线 程， 而 在 这 个 线 程 中 不 能 有 阻 塞 型 调 用， 因 为 事 件 循 环 也 在 这 个 线 程 中 运 行。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16496</div><div class='noteText'>在 yield from 表 达 式 中 把 semaphore 当 成 上 下 文 管 理 器 使 用， 防 止 阻 塞 整 个 系 统： 如 果 semaphore 计 数 器 的 值 是 所 允 许 的 最 大 值， 只 有 这 个 协 程 会 阻 塞。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16500</div><div class='noteText'>退 出 这 个 with 语 句 后， semaphore 计 数 器 的 值 会 递 减， 解 除 阻 塞 可 能 在 等 待 同 一 个 semaphore 对 象 的 其 他 协 程 实 例。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16518</div><div class='noteText'>是， 在 downloader_coro 函 数 中 创 建 一 个 asyncio.Semaphore 实 例（ 在 后 面 的 示 例 18-8 中）， 然 后 把 它 传 给 示 例 18-7 中 download_one 函 数 的 semaphore 参 数。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16524</div><div class='noteText'>Semaphore 对 象 维 护 着 一 个 内 部 计 数 器， 若 在 对 象 上 调 用 .acquire() 协 程 方 法， 计 数 器 则 递 减； 若 在 对 象 上 调 用 .release() 协 程 方 法， 计 数 器 则 递 增。 计 数 器 的 初 始 值 在 实 例 化 Semaphore 时 设 定，</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16540</div><div class='noteText'>with (yield from semaphore): image = yield from get_flag( base_url, cc)</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16541</div><div class='noteText'>这 段 代 码 保 证， 任 何 时 候 都 不 会 有 超 过 concur_req 个 get_flag 协 程 启 动。</div>
<div class='sectionHeading'>18.4.2　使用Executor对象，防止阻塞事件循环</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16623</div><div class='noteText'>Python 社 区 往 往 会 忽 略 一 个 事 实—— 访 问 本 地 文 件 系 统 会 阻 塞， 想 当 然 地 认 为 这 种 操 作 不 会 受 网 络 访 问 的 高 延 迟 影 响（ 这 也 极 难 预 料）。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16631</div><div class='noteText'>中， save_flag 函 数 阻 塞 了 客 户 代 码 与 asyncio 事 件 循 环 共 用 的 唯 一 线 程， 因 此 保 存 文 件 时， 整 个 应 用 程 序 都 会 冻 结。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16633</div><div class='noteText'>使 用 事 件 循 环 对 象 的 run_in_executor 方 法。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16635</div><div class='noteText'>asyncio 的 事 件 循 环 在 背 后 维 护 着 一 个 ThreadPoolExecutor 对 象， 我 们 可 以 调 用 run_in_executor 方 法， 把 可 调 用 的 对 象 发 给 它 执 行。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16663</div><div class='noteText'>如 果 需 要 协 调 异 步 请 求， 而 不 只 是 发 起 完 全 独 立 的 请 求， 协 程 较 之 回 调 的 好 处 会 变 得 显 而 易 见。</div>
<div class='sectionHeading'>18.5　从回调到期物和协程</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16728</div><div class='noteText'>只 要 函 数 中 有 yield from， 函 数 就 会 变 成 协 程， 而 协 程 不 能 直 接 调 用，</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16730</div><div class='noteText'>我 们 必 须 使 用 事 件 循 环 显 式 排 定 协 程 的 执 行 时 间， 或 者 在 其 他 排 定 了 执 行 时 间 的 协 程 中 使 用 yield from 表 达 式 把 它 激 活。 如 果 示 例 18-12 没 有 最 后 一 行（ loop.create_task( three_stages( request1))）， 那 么 什 么 也 不 会 发 生。</div>
<div class='sectionHeading'>每次下载发起多次请求</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16741</div><div class='noteText'>解 决 方 法 虽 然 没 有 使 用 多 个 线 程 那 么 简 单， 但 是 比 链 式 或 嵌 套 回 调 易 于 管 理。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16794</div><div class='noteText'>单， yield from 只 能 用 于 协 程 和 asyncio.Future 实 例（ 包 括 Task 实 例）。</div>
<div class='sectionHeading'>18.6.1　使用asyncio包编写TCP服务器</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 16955</div><div class='noteText'>asyncio 包 提 供 的 高 层 流 API， 有 现 成 的 服 务 器 可 用， 所 以 我 们 只 需 实 现 一 个 处 理 程 序（ 普 通 的 回 调 或 协 程）。 此 外， asyncio 包 受 Twisted 框 架 中 抽 象 的 传 送 和 协 议 启 发， 还 提 供 了 低 层 传 送 和 协 议 API。 详 情 请 参 见 asyncio 包 的 文 档， 里 面 有 一 个 使 用 低 层 API 实 现 的 TCP 回 显 服 务 器。</div>
<div class='sectionHeading'>18.6.3　更好地支持并发的智能客户端</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 17071</div><div class='noteText'>除 了 防 止 阻 塞 调 用 之 外， 高 并 发 的 系 统 还 必 须 把 复 杂 的 工 作 分 成 多 步， 以 保 持 敏 捷。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 17081</div><div class='noteText'>避 免 响 应 时 间 太 长 的 方 法 是 实 现 分 页： 首 次 至 多 返 回（ 比 如 说） 200 行， 用 户 点 击 链 接 或 滚 动 页 面 时 再 获 取 更 多 结 果。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 17089</div><div class='noteText'>这 种 客 户 端 服 务， 我 们 需 要 全 方 位 支 持 异 步 编 程 的 框 架， 从 处 理 HTTP 请 求 和 响 应 到 访 问 数 据 库， 全 都 支 持 异 步。 如 果 想 实 现 实 时 服 务， 例 如 游 戏 和 以 WebSockets 支 持 的 媒 体 流， 那 就 尤 其 应 该 这 么 做。</div>
<div class='sectionHeading'>18.8　延伸阅读</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 17186</div><div class='noteText'>到， Twisted 是 Node.js 的 灵 感 来 源 之 一； 而 在 Python 中， Tornado 拥 护 使 用 协 程 做 面 向 事 件 编 程。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 17188</div><div class='noteText'>Ryan Dahl 决 定 统 一 只 用 回 调。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 17211</div><div class='noteText'>新。 鉴 于 这 样 的 需 求， 服 务 器 端 最 好 使 用 异 步 框 架， 不 要 使 用 传 统 的 Web 框 架（ 如 Django）。 传 统 框 架 的 目 的 是 渲 染 完 整 的 HTML 网 页， 而 且 不 支 持 异 步 访 问 数 据 库。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 17235</div><div class='noteText'>若 想 精 通 asyncio 包， 一 定 要 下 一 番 功 夫。 可 是， 如 果 你 计 划 使 用 Python 编 写 并 发 网 络 应 用， 那 就 去 寻 求 至 尊 循 环（ the One Loop）：</div>
<div class='sectionHeading'>第 19 章　动态属性和特性</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 17261</div><div class='noteText'>动 态 创 建 属 性 是 一 种 元 编 程， 框 架 的 作 者 经 常 这 么 做。 然 而， 在 Python 中， 相 关 的 基 础 技 术 十 分 简 单， 任 何 人 都 可 以 使 用， 甚 至 在 日 常 的 数 据 转 换 任 务 中 也 能 用 到。</div>
<div class='sectionHeading'>19.1.3　使用 __new__ 方法以灵活的方式创建对象</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 17476</div><div class='noteText'>其 实， 用 于 构 建 实 例 的 是 特 殊 方 法 __new__： 这 是 个 类 方 法（ 使 用 特 殊 方 式 处 理， 因 此 不 必 使 用 @classmethod 装 饰 器）， 必 须 返 回 一 个 实 例。 返 回 的 实 例 会 作 为 第 一 个 参 数（ 即 self） 传 给 __init__ 方 法。 因 为 调 用 __init__ 方 法 时 要 传 入 实 例， 而 且 禁 止 返 回 任 何 值， 所 以 __init__ 方 法 其 实 是“ 初 始 化 方 法”。 真 正 的 构 造 方 法 是 __new__。 我 们 几 乎 不 需 要 自 己 编 写 __new__ 方 法， 因 为 从 object 类 继 承 的 实 现 已 经 足 够 了。</div>
<div class='sectionHeading'>19.1.5　使用特性获取链接的记录</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 17863</div><div class='noteText'>本 章 目 前 所 举 的 示 例 是 为 了 展 示 如 何 使 用 基 本 的 工 具， 如 __getattr__ 方 法、 hasattr 函 数、 getattr 函 数、@ property 装 饰 器 和 __dict__ 属 性， 来 实 现 动 态 属 性。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 17867</div><div class='noteText'>特 性 经 常 用 于 把 公 开 的 属 性 变 成 使 用 读 值 方 法 和 设 值 方 法 管 理 的 属 性，</div>
<div class='sectionHeading'>20.1.1　LineItem类第3版：一个简单的描述符</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 18445</div><div class='noteText'>实 现 了 __get__、__set__ 或 __delete__ 方 法 的 类 是 描 述 符。 描 述 符 的 用 法 是， 创 建 一 个 实 例， 作 为 另 一 个 类 的 类 属 性。</div>
<div class='sectionHeading'>第 21 章　类元编程</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 19211</div><div class='noteText'>导 入 时 和 运 行 时 的 区 别—— 这 是 有 效 使 用 Python 元 编 程 的 重 要 基 础。</div>
<div class='sectionHeading'>21.4　元类基础知识</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 19494</div><div class='noteText'>元 类 是 制 造 类 的 工 厂， 不 过 不 是 函 数（ 如 示 例 21-2 中 的 record_factory）， 而 是 类。 图 21-1 使 用 机 器 和 小 怪 兽 图 示 法 描 述 元 类， 可 以 看 出， 元 类 是 生 产 机 器 的 机 器。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 19525</div><div class='noteText'>除 了 type， 标 准 库 中 还 有 一 些 别 的 元 类， 例 如 ABCMeta 和 Enum。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 19536</div><div class='noteText'>ABCMeta 最 终 所 属 的 类 也 是 type。 所 有 类 都 直 接 或 间 接 地 是 type 的 实 例， 不 过 只 有 元 类 同 时 也 是 type 的 子 类。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 19538</div><div class='noteText'>若 想 理 解 元 类， 一 定 要 知 道 这 种 关 系： 元 类（ 如 ABCMeta） 从 type 类 继 承 了 构 建 类 的 能 力。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 19547</div><div class='noteText'>ABCMeta 还 是 type 的 子 类， 因 为 ABCMeta 是 元 类。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 19550</div><div class='noteText'>我 们 要 抓 住 的 重 点 是， 所 有 类 都 是 type 的 实 例， 但 是 元 类 还 是 type 的 子 类， 因 此 可 以 作 为 制 造 类 的 工 厂。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 19552</div><div class='noteText'>具 体 来 说， 元 类 可 以 通 过 实 现 __init__ 方 法 定 制 实 例。 元 类 的 __init__ 方 法 可 以 做 到 类 装 饰 器 能 做 的 任 何 事 情， 但 是 作 用 更 大，</div>
<div class='sectionHeading'>理解元类计算时间的练习</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 19648</div><div class='noteText'>　 如 果 想 进 一 步 定 制 类， 可 以 在 元 类 中 实 现 __new__ 方 法。 不 过， 通 常 情 况 下 实 现 __init__ 方 法 就 够 了。</div>
<div class='sectionHeading'>21.6　元类的特殊方法 __prepare__</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 19703</div><div class='noteText'>述， type 构 造 方 法 及 元 类 的 __new__ 和 __init__ 方 法 都 会 收 到 要 计 算 的 类 的 定 义 体， 形 式 是 名 称 到 属 性 的 映 像。 然 而 在 默 认 情 况 下， 那 个 映 射 是 字 典； 也 就 是 说， 元 类 或 类 装 饰 器 获 得 映 射 时， 属 性 在 类 定 义 体 中 的 顺 序 已 经 丢 失 了。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 19707</div><div class='noteText'>这 个 问 题 的 解 决 办 法 是， 使 用 Python 3 引 入 的 特 殊 方 法 __prepare__。 这 个 特 殊 方 法 只 在 元 类 中 有 用， 而 且 必 须 声 明 为 类 方 法（ 即， 要 使 用 @classmethod 装 饰 器 定 义）。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 19709</div><div class='noteText'>解 释 器 调 用 元 类 的 __new__ 方 法 之 前 会 先 调 用 __prepare__ 方 法， 使 用 类 定 义 体 中 的 属 性 创 建 映 射。__prepare__ 方 法 的 第 一 个 参 数 是 元 类， 随 后 两 个 参 数 分 别 是 要 构 建 的 类 的 名 称 和 基 类 组 成 的 元 组， 返 回 值 必 须 是 映 射。 元 类 构 建 新 类 时，__prepare__ 方 法 返 回 的 映 射 会 传 给 __new__ 方 法 的 最 后 一 个 参 数， 然 后 再 传 给 __init__ 方 法。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 19753</div><div class='noteText'>中， 框 架 和 库 会 使 用 元 类 协 助 程 序 员 执 行 很 多 任 务， 例 如：</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 19754</div><div class='noteText'>验 证 属 性 一 次 把 装 饰 器 依 附 到 多 个 方 法 上 序 列 化 对 象 或 转 换 数 据 对 象 关 系 映 射 基 于 对 象 的 持 久 存 储</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 19757</div><div class='noteText'>动 态 转 换 使 用 其 他 语 言 编 写 的 类 结 构</div>
<div class='sectionHeading'>21.9　延伸阅读</div><div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 19861</div><div class='noteText'>计 算 机 科 学 教 育 的 任 务 是 教 人 如 何 拓 展 思 维， 打 破 常 规， 学 习 以 更 广 博、 更 强 大 和 更 灵 活 的 方 式 思 考， 让 思 维 超 越 程 序。 编 程 思 想 的 各 个 方 面 在 程 序 中 必 会 得 到 充 分 体 现。</div>
<div class='noteHeading'>标注 (<span class='highlight_orange'>橙色</span>) - 位置 19878</div><div class='noteText'>我 还 未 见 过 有 哪 门 语 言 像 Python 这 样 竭 尽 所 能， 让 初 学 者 易 于 入 门， 让 专 业 人 士 用 着 顺 手， 让 程 序 高 手 欢 欣 鼓 舞。</div>
</div> 
</body> 
</html> 
